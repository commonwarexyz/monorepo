//! Local network setup.

use commonware_codec::Encode;
use commonware_cryptography::{
    ed25519::{PrivateKey, PublicKey},
    PrivateKeyExt, Signer,
};
use commonware_runtime::{
    tokio::{self, telemetry::Logging},
    Metrics, Runner,
};
use commonware_utils::hex;
use rand::{rngs::OsRng, seq::IteratorRandom};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    fs::{self, File},
    net::{IpAddr, Ipv4Addr, SocketAddr},
    path::PathBuf,
};
use tracing::{error, info};

/// A configuration for a validator participant generated by the [setup](run) procedure.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParticipantConfig {
    /// The port for P2P to listen on.
    pub port: u16,
    /// The bootstrapper node identities.
    #[serde(with = "serde_peer_map")]
    pub bootstrappers: HashMap<PublicKey, SocketAddr>,
    /// The validator's p2p private key.
    #[serde(with = "serde_hex")]
    pub signing_key: PrivateKey,
}

/// A list of all peers' public keys.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerConfig {
    /// All active peer public keys.
    #[serde(with = "serde_hex_vec")]
    pub active: Vec<PublicKey>,
}

/// Run the setup procedure, generating a number of random validator identities.
pub fn run(runtime_args: super::RuntimeArgs, args: super::SetupArgs) {
    let config = tokio::Config::new()
        .with_worker_threads(runtime_args.worker_threads)
        .with_tcp_nodelay(Some(true))
        .with_catch_panics(false);
    let runner = tokio::Runner::new(config);
    runner.start(|context| async move {
        // Initialize telemetry.
        tokio::telemetry::init(
            context.with_label("telemetry"),
            Logging {
                level: runtime_args.log_level,
                json: false,
            },
            None,
            None,
        );

        if args.datadir.exists() {
            error!("Data directory already exists; Remove it before setting up a new network");
            return;
        }

        fs::create_dir_all(&args.datadir).unwrap();

        let identities = generate_identities(args.num_participants);
        let configs = generate_configs(&args, &identities);

        println!("\nTo start the validators, run the following command:");
        let mprocs_cmd = configs
            .into_iter()
            .fold(vec!["mprocs".to_string()], |mut acc, cfg| {
                acc.push(format!(
                    "\"cargo run --bin commonware-dkg --release participant --cfg {} --peers {}\"",
                    cfg.display(),
                    args.datadir.join("peers.json").display()
                ));
                acc
            })
            .join(" ");
        println!("\n{mprocs_cmd}");
    });
}

/// Generate shares, ed25519 private keys, and a commitment for a given number of participants.
fn generate_identities(num_peers: u32) -> Vec<PrivateKey> {
    // Generate p2p private keys
    let mut signers = (0..num_peers)
        .map(|_| PrivateKey::from_rng(&mut OsRng))
        .collect::<Vec<_>>();
    signers.sort_by_key(|signer| signer.public_key());

    info!(num_peers, "generated participant identities");
    signers
}

/// Generates all [ParticipantConfig] files from the provided identities.
fn generate_configs(args: &super::SetupArgs, identities: &[PrivateKey]) -> Vec<PathBuf> {
    let bootstrappers = identities
        .iter()
        .enumerate()
        .choose_multiple(&mut OsRng, args.num_bootstrappers)
        .into_iter()
        .map(|(i, signer)| {
            (
                signer.public_key(),
                SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), args.base_port + i as u16),
            )
        })
        .collect::<HashMap<_, _>>();

    let mut configs = Vec::with_capacity(identities.len());
    for (index, signer) in identities.iter().enumerate() {
        let config_path = args.datadir.join(format!("participant-{}.json", index));
        let participant_config = ParticipantConfig {
            port: args.base_port + index as u16,
            bootstrappers: bootstrappers.clone(),
            signing_key: signer.clone(),
        };
        let config_file = File::create(&config_path).unwrap();
        serde_json::to_writer_pretty(config_file, &participant_config).unwrap();

        configs.push(config_path);
    }
    info!("wrote participant configurations");

    let peers = PeerConfig {
        active: identities
            .iter()
            .map(|signer| signer.public_key())
            .collect(),
    };
    let peers_file = File::create(args.datadir.join("peers.json")).unwrap();
    serde_json::to_writer_pretty(peers_file, &peers).unwrap();
    info!("wrote peers map");

    configs
}

// --- `serde` helpers ---

mod serde_hex {
    use super::*;
    use commonware_codec::DecodeExt;
    use commonware_utils::from_hex;
    use serde::{Deserializer, Serializer};
    use serde_json::Value;

    pub fn serialize<T, S>(value: &T, serializer: S) -> Result<S::Ok, S::Error>
    where
        T: Encode,
        S: Serializer,
    {
        hex(&value.encode()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
    where
        T: DecodeExt<()>,
        D: Deserializer<'de>,
    {
        if let Value::String(s) = Value::deserialize(deserializer)? {
            let bytes = from_hex(&s).ok_or(serde::de::Error::custom(
                "failed to deserialize: invalid hex string",
            ))?;
            T::decode(&mut bytes.as_slice())
                .map_err(|_| serde::de::Error::custom("failed to decode bytes"))
        } else {
            Err(serde::de::Error::custom(
                "failed to deserialize: expected a hex string",
            ))
        }
    }
}

mod serde_hex_vec {
    use super::*;
    use commonware_codec::DecodeExt;
    use commonware_utils::from_hex;
    use core::fmt;
    use serde::{
        de::{SeqAccess, Visitor},
        Deserializer, Serializer,
    };

    pub fn serialize<T, S>(value: &[T], serializer: S) -> Result<S::Ok, S::Error>
    where
        T: Encode,
        S: Serializer,
    {
        // Serialize each element as a hex string
        serializer.collect_seq(value.iter().map(|v| hex(&v.encode())))
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<Vec<T>, D::Error>
    where
        T: DecodeExt<()>,
        D: Deserializer<'de>,
    {
        struct HexVecVisitor<T>(std::marker::PhantomData<T>);

        impl<'de, T> Visitor<'de> for HexVecVisitor<T>
        where
            T: DecodeExt<()>,
        {
            type Value = Vec<T>;

            fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("a sequence of hex-encoded values")
            }

            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: SeqAccess<'de>,
            {
                let mut out = Vec::with_capacity(seq.size_hint().unwrap_or(0));
                while let Some(s) = seq.next_element::<String>()? {
                    let bytes = from_hex(&s).ok_or(serde::de::Error::custom(
                        "failed to convert from hex to bytes",
                    ))?;

                    out.push(T::decode(&mut bytes.as_ref()).map_err(serde::de::Error::custom)?);
                }
                Ok(out)
            }
        }

        deserializer.deserialize_seq(HexVecVisitor(std::marker::PhantomData))
    }
}

mod serde_peer_map {
    use super::*;
    use commonware_codec::DecodeExt;
    use commonware_utils::from_hex;
    use serde::{Deserializer, Serializer};
    use serde_json::Value;

    pub fn serialize<S: Serializer>(
        value: &HashMap<PublicKey, SocketAddr>,
        serializer: S,
    ) -> Result<S::Ok, S::Error> {
        let hex_map = value
            .iter()
            .map(|(k, v)| (hex(&k.encode()), *v))
            .collect::<HashMap<_, _>>();
        hex_map.serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<PublicKey, SocketAddr>, D::Error>
    where
        D: Deserializer<'de>,
    {
        if let Value::Object(map) = Value::deserialize(deserializer)? {
            let mut result = HashMap::new();
            for (k, v) in map {
                let pk_bytes = from_hex(&k).ok_or(serde::de::Error::custom(
                    "failed to deserialize: invalid hex string for public key",
                ))?;
                let pk = PublicKey::decode(&mut pk_bytes.as_slice())
                    .map_err(|_| serde::de::Error::custom("failed to decode public key bytes"))?;

                let Value::String(addr_str) = v else {
                    return Err(serde::de::Error::custom(
                        "failed to deserialize: expected a string for socket address",
                    ));
                };
                let socket_addr = addr_str.parse::<SocketAddr>().map_err(|_| {
                    serde::de::Error::custom("failed to parse socket address from string")
                })?;

                result.insert(pk, socket_addr);
            }
            Ok(result)
        } else {
            Err(serde::de::Error::custom(
                "failed to deserialize: expected a map",
            ))
        }
    }
}
