#![doc = include_str!("../README.md")]
#![doc(
    html_logo_url = "https://commonware.xyz/imgs/rustdoc_logo.svg",
    html_favicon_url = "https://commonware.xyz/favicon.ico"
)]

// Allow proc-macro expansions to reference this crate as `::commonware_actor`
// in in-crate tests, doctests, and downstream crates with one stable path.
#[allow(unused_extern_crates)]
extern crate self as commonware_actor;

use commonware_macros::stability_scope;

stability_scope!(ALPHA {
    use std::{fmt::{Debug, Display}, future::Future};

    pub mod mailbox;
    pub mod service;

    #[doc(hidden)]
    pub use commonware_utils::channel::oneshot;
    pub use commonware_actor_macros::ingress;

    /// Stateful task driven by the actor control loop.
    ///
    /// # Lifecycle
    ///
    /// In driver mode ([`service::ServiceBuilder`]), hooks run in this order:
    ///
    /// 1. `on_startup` once (receives [`Actor::Args`] data).
    /// 2. Per iteration: `preprocess`, then race lanes against
    ///    `on_external` for one event. If a message is received (`Some`),
    ///    dispatch to `on_read_only` (concurrent) or `on_read_write` (serial),
    ///    then `postprocess`. If the source
    ///    yields `None` (lane closed or `on_external` exhaustion), skip
    ///    directly to `on_shutdown`.
    /// 3. `on_shutdown` once, on graceful exit (runtime stop, lane closure,
    ///    or `on_external` returning `None`).
    ///
    /// Returning `Err` from `on_read_only` or `on_read_write` is fatal: the error is logged,
    /// remaining in-flight reads are drained, and then `on_shutdown` is called
    /// before the loop exits.
    pub trait Actor<E>: Send + 'static {
        /// Typed mailbox returned by the service builder.
        ///
        /// Set this to the mailbox wrapper generated by [`ingress!`] so that
        /// [`service::ServiceBuilder::build`] returns the typed mailbox
        /// directly.
        type Mailbox: Send + Clone + 'static;

        /// Envelope ingress type consumed by the service mailbox.
        ///
        /// Generated mailbox wrappers from [`ingress!`] set this to
        /// `<MailboxName>Message`.
        type Ingress: IntoIngressEnvelope;

        /// Fatal error type returned by [`Actor::on_read_only`] and [`Actor::on_read_write`].
        ///
        /// Returning `Err` from read/write handlers logs the error and stops the
        /// actor.
        type Error: Debug + Display + Send + 'static;

        /// Snapshot type used by concurrent read-only ingress handlers.
        ///
        /// Must be cheap to create and clone. Prefer `Arc`-backed structures
        /// or `Copy` types; avoid deep cloning large data structures.
        type Snapshot: Clone + Send + 'static;

        /// Data provided to the service on start up.
        ///
        /// Use `()` for actors that do not need external start-up data.
        /// Actors with non-unit `Args` must be started via
        /// [`service::ActorService::start_with`].
        type Args: Send + 'static;

        /// Runs once when the control loop starts.
        ///
        /// `args` carries externally-provided data that the actor needs before
        /// processing messages (e.g., connection handles, peer identity).
        fn on_startup(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
        ) -> impl Future<Output = ()> + Send {
            async {}
        }

        /// Runs once when the control loop stops gracefully.
        ///
        /// Called on: runtime shutdown signal, lane closure,
        /// [`Actor::on_external`] returning `None`, or after a fatal handler
        /// error from [`Actor::on_read_only`] or [`Actor::on_read_write`].
        fn on_shutdown(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
        ) -> impl Future<Output = ()> + Send {
            async {}
        }

        /// Runs at the beginning of each iteration, before polling for events.
        ///
        /// Use this for periodic housekeeping that should run every loop
        /// iteration regardless of which event fires (e.g., cleaning stale
        /// subscriptions, refreshing state).
        fn preprocess(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
        ) -> impl Future<Output = ()> + Send {
            async {}
        }

        /// Create a snapshot for handling read-only ingress concurrently.
        ///
        /// The service loop captures this snapshot when a read-only message is
        /// admitted, then executes [`Actor::on_read_only`] in a spawned task.
        ///
        /// This must be cheap to create. Prefer `Arc`-backed structures or
        /// `Copy` types. Avoid deep cloning large data structures, as
        /// `snapshot` is called on every read-only message.
        fn snapshot(&self, args: &Self::Args) -> Self::Snapshot;

        /// Handle one read-only ingress message.
        ///
        /// Read-only handlers execute concurrently on spawned tasks, receive only
        /// the captured `snapshot`, and must not mutate actor state. The
        /// `context` parameter is a clone of the actor's runtime context,
        /// suitable for spawning sub-tasks, accessing metrics, etc.
        ///
        /// Returning `Err` is fatal: the service loop logs the error, drains
        /// remaining in-flight reads, and then calls [`Actor::on_shutdown`]
        /// before exiting.
        fn on_read_only(
            _context: E,
            _snapshot: Self::Snapshot,
            _message: <Self::Ingress as IntoIngressEnvelope>::ReadOnlyIngress,
        ) -> impl Future<Output = Result<(), Self::Error>> + Send {
            futures::future::pending()
        }

        /// Handle one ingress message that may mutate actor state.
        ///
        /// Read-write handlers execute serially on the actor loop and are fenced
        /// behind in-flight read-only handlers that were dispatched before the
        /// write arrived. Reads dispatched after are not waited on.
        ///
        /// Returning `Err` is fatal: the service loop logs the error, drains
        /// remaining in-flight reads, and then calls [`Actor::on_shutdown`]
        /// before exiting.
        fn on_read_write(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
            _message: <Self::Ingress as IntoIngressEnvelope>::ReadWriteIngress,
        ) -> impl Future<Output = Result<(), Self::Error>> + Send {
            futures::future::pending()
        }

        /// Poll external per-iteration sources and map them to ingress.
        ///
        /// The service loop recreates this future each iteration and races it
        /// against lane receivers. Returning `Some(ingress)` dispatches one
        /// event via [`Actor::on_read_write`]. Returning `None` signals
        /// exhaustion and stops the actor (calls [`Actor::on_shutdown`]).
        ///
        /// # Cancellation safety
        ///
        /// This future is dropped and recreated whenever a lane message wins
        /// the race. Implementations must be **cancellation-safe**: any work
        /// done before an internal `.await` point may be lost if the future
        /// is cancelled at that point. Hold intermediate state in `self` or
        /// `args` rather than in local variables across `.await` boundaries.
        fn on_external(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
        ) -> impl Future<Output = Option<<Self::Ingress as IntoIngressEnvelope>::ReadWriteIngress>> + Send {
            futures::future::pending()
        }

        /// Runs at the end of each iteration that dispatched a message.
        ///
        /// Not guaranteed to be called after every single message. When
        /// multiple read-only messages are batched concurrently,
        /// `postprocess` may only run after the full batch completes.
        fn postprocess(
            &mut self,
            _context: &mut E,
            _args: &mut Self::Args,
        ) -> impl Future<Output = ()> + Send {
            async {}
        }
    }

    /// Envelope class used by the service loop scheduler.
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum IngressEnvelope<R, W> {
        /// Read-only ingress executed concurrently on a snapshot.
        ReadOnly(R),
        /// Read-write ingress executed serially on the control loop.
        ReadWrite(W),
    }

    /// Conversion trait from mailbox ingress into a scheduler envelope.
    pub trait IntoIngressEnvelope: Send + 'static {
        /// Read-only ingress branch.
        type ReadOnlyIngress: Send + 'static;
        /// Read-write ingress branch.
        type ReadWriteIngress: Send + 'static;

        /// Convert this value into either a read-only or read-write envelope.
        fn into_ingress_envelope(
            self,
        ) -> IngressEnvelope<Self::ReadOnlyIngress, Self::ReadWriteIngress>;
    }

    /// Ask-response conversion trait for mailbox APIs.
    ///
    /// An ask type converts itself into the actor's ingress enum by embedding a
    /// oneshot response channel into the produced ingress message.
    pub trait Ask<I>: Send + 'static {
        /// Response type expected from the actor.
        type Response: Send + 'static;

        /// Convert this ask into an ingress value with a response sender.
        fn into_ingress(self, response: oneshot::Sender<Self::Response>) -> I;
    }

    /// Fire-and-forget conversion trait for mailbox APIs.
    ///
    /// Maps wrapper types into ingress without closure boxing.
    pub trait Tell<I>: Send + 'static {
        /// Convert this tell message into an ingress value.
        fn into_ingress(self) -> I;
    }
});
