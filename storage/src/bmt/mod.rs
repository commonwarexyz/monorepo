//! Stateless Binary Merkle Tree (BMT).
//!
//! The Binary Merkle Tree is constructed level-by-level. The first level consists of position-hashed leaf digests.
//! On each additional level, pairs of nodes are hashed from the previous level (if a level contains an odd
//! number of nodes, the last node is duplicated). The finalized root of the tree incorporates the leaf count
//! to prevent proof malleability attacks: `root = hash(leaf_count || tree_root)`.
//!
//! For example, given three leaves A, B, and C, the tree is constructed as follows:
//!
//! ```text
//!     Level 2 (tree_root):  [hash(hash(hash(0,A),hash(1,B)),hash(hash(2,C),hash(2,C)))]
//!     Level 1:              [hash(hash(0,A),hash(1,B)),hash(hash(2,C),hash(2,C))]
//!     Level 0 (leaves):     [hash(0,A),hash(1,B),hash(2,C)]
//!     Finalized root:       hash(3 || tree_root)
//! ```
//!
//! A proof for one or more leaves is generated by collecting the siblings needed to reconstruct the root.
//! An external process can then use this proof (with some trusted root) to verify that the leaves
//! are part of the tree.
//!
//! # Example
//!
//! ```rust
//! use commonware_storage::bmt::{Builder, Tree};
//! use commonware_cryptography::{Sha256, sha256::Digest, Hasher as _};
//!
//! // Create transactions and compute their digests
//! let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
//! let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
//!
//! // Build a Merkle Tree from the digests
//! let mut builder = Builder::<Sha256>::new(digests.len());
//! for digest in &digests {
//!    builder.add(digest);
//! }
//! let tree = builder.build();
//! let root = tree.root();
//!
//! // Generate a proof for leaf at index 1
//! let mut hasher = Sha256::default();
//! let proof = tree.proof(1).unwrap();
//! assert!(proof.verify_element_inclusion(&mut hasher, &digests[1], 1, &root).is_ok());
//! ```

use alloc::collections::btree_set::BTreeSet;
use bytes::{Buf, BufMut};
use commonware_codec::{EncodeSize, Read, ReadExt, ReadRangeExt, Write};
use commonware_cryptography::{Digest, Hasher};
use commonware_utils::{non_empty_vec, vec::NonEmptyVec};
use thiserror::Error;

/// There should never be more than 255 levels in a proof (would mean the Binary Merkle Tree
/// has more than 2^255 leaves).
pub const MAX_LEVELS: usize = u8::MAX as usize;

/// Errors that can occur when working with a Binary Merkle Tree (BMT).
#[derive(Error, Debug)]
pub enum Error {
    #[error("invalid position: {0}")]
    InvalidPosition(u32),
    #[error("invalid proof: {0} != {1}")]
    InvalidProof(String, String),
    #[error("no leaves")]
    NoLeaves,
    #[error("unaligned proof")]
    UnalignedProof,
    #[error("duplicate position: {0}")]
    DuplicatePosition(u32),
}

/// Constructor for a Binary Merkle Tree (BMT).
pub struct Builder<H: Hasher> {
    hasher: H,
    leaves: Vec<H::Digest>,
}

impl<H: Hasher> Builder<H> {
    /// Creates a new Binary Merkle Tree builder.
    pub fn new(leaves: usize) -> Self {
        Self {
            hasher: H::new(),
            leaves: Vec::with_capacity(leaves),
        }
    }

    /// Adds a leaf to the Binary Merkle Tree.
    ///
    /// When added, the leaf is hashed with its position.
    pub fn add(&mut self, leaf: &H::Digest) -> u32 {
        let position: u32 = self.leaves.len().try_into().expect("too many leaves");
        self.hasher.update(&position.to_be_bytes());
        self.hasher.update(leaf);
        self.leaves.push(self.hasher.finalize());
        position
    }

    /// Builds the Binary Merkle Tree.
    ///
    /// It is valid to build a tree with no leaves, in which case
    /// just an "empty" node is included (no leaves will be provable).
    pub fn build(self) -> Tree<H> {
        Tree::new(self.hasher, self.leaves)
    }
}

/// Constructed Binary Merkle Tree (BMT).
#[derive(Clone, Debug)]
pub struct Tree<H: Hasher> {
    /// Records whether the tree is empty.
    empty: bool,

    /// The digests at each level of the tree (from leaves to root).
    levels: NonEmptyVec<NonEmptyVec<H::Digest>>,

    /// The finalized root digest, which incorporates the leaf count.
    ///
    /// This is computed as `H(leaf_count || tree_root)` to prevent
    /// proof malleability attacks where different tree sizes could
    /// produce valid proofs for the same root.
    root: H::Digest,
}

impl<H: Hasher> Tree<H> {
    /// Builds a Merkle Tree from a slice of position-hashed leaf digests.
    fn new(mut hasher: H, mut leaves: Vec<H::Digest>) -> Self {
        // If no leaves, add an empty node.
        //
        // Because this node only includes a position, there is no way a valid proof
        // can be generated that references it.
        let mut empty = false;
        let leaf_count = leaves.len() as u32;
        if leaves.is_empty() {
            leaves.push(hasher.finalize());
            empty = true;
        }

        // Create the first level
        let mut levels = non_empty_vec![non_empty_vec![@leaves]];

        // Construct the tree level-by-level
        let mut current_level = levels.last();
        while !current_level.is_singleton() {
            let mut next_level = Vec::with_capacity(current_level.len().get().div_ceil(2));
            for chunk in current_level.chunks(2) {
                // Hash the left child
                hasher.update(&chunk[0]);

                // Hash the right child
                if chunk.len() == 2 {
                    hasher.update(&chunk[1]);
                } else {
                    // If no right child exists, duplicate left child.
                    hasher.update(&chunk[0]);
                };

                // Compute the parent digest
                next_level.push(hasher.finalize());
            }

            // Add the computed level to the tree
            levels.push(non_empty_vec![@next_level]);
            current_level = levels.last();
        }

        // Compute the finalized root: H(leaf_count || tree_root)
        // This binds the root to the tree size, preventing malleability attacks.
        let tree_root = levels.last().first();
        hasher.update(&leaf_count.to_be_bytes());
        hasher.update(tree_root);
        let root = hasher.finalize();

        Self {
            empty,
            levels,
            root,
        }
    }

    /// Returns the finalized root of the tree.
    ///
    /// The root incorporates the leaf count via `H(leaf_count || tree_root)`,
    /// which prevents proof malleability attacks where different tree sizes
    /// could produce valid proofs for the same root.
    pub const fn root(&self) -> H::Digest {
        self.root
    }

    /// Generates a Merkle proof for the leaf at `position`.
    ///
    /// This is a single-element multi-proof, which includes the minimal siblings
    /// needed to reconstruct the root.
    pub fn proof(&self, position: u32) -> Result<Proof<H::Digest>, Error> {
        self.multi_proof(&[position])
    }

    /// Generates a Merkle range proof for a contiguous set of leaves from `start`
    /// to `end` (inclusive).
    ///
    /// The proof contains the minimal set of sibling digests needed to reconstruct
    /// the root for all elements in the range. This is more efficient than individual
    /// proofs when proving multiple consecutive elements.
    pub fn range_proof(&self, start: u32, end: u32) -> Result<RangeProof<H::Digest>, Error> {
        // For empty trees, return an empty proof
        if self.empty && start == 0 && end == 0 {
            return Ok(RangeProof::default());
        }

        // Ensure the range is within bounds
        if start > end {
            return Err(Error::InvalidPosition(start));
        }
        let leaf_count = self.levels.first().len().get() as u32;
        if start >= leaf_count {
            return Err(Error::InvalidPosition(start));
        }
        if end >= leaf_count {
            return Err(Error::InvalidPosition(end));
        }

        // For each level (except the root level) collect the necessary siblings
        let mut siblings = Vec::new();
        for (level_idx, level) in self.levels.iter().enumerate() {
            // If the level has only one node, we're done
            if level.is_singleton() {
                break;
            }

            // Calculate the range of indices at this level
            let level_start = (start as usize) >> level_idx;
            let level_end = (end as usize) >> level_idx;

            // Check if we need a left sibling
            let mut left = None;
            if level_start % 2 == 1 {
                // Our range starts at an odd index, so we need the even sibling to the left
                left = Some(level[level_start - 1]);
            }

            // Check if we need a right sibling
            let mut right = None;
            if level_end.is_multiple_of(2) {
                if level_end + 1 < level.len().get() {
                    // Our range ends at an even index, so we need the odd sibling to the right
                    right = Some(level[level_end + 1]);
                } else {
                    // If no right child exists, use a duplicate of the current node.
                    //
                    // This doesn't affect the robustness of the proof (allow a non-existent position
                    // to be proven or enable multiple proofs to be generated from a single leaf).
                    right = Some(level[level_end]);
                }
            }

            siblings.push(Bounds { left, right });
        }

        Ok(RangeProof {
            leaf_count,
            siblings,
        })
    }

    /// Generates a Merkle proof for multiple non-contiguous leaves at the given `positions`.
    ///
    /// The proof contains the minimal set of sibling digests needed to reconstruct
    /// the root for all elements at the specified positions. This is more efficient
    /// than individual proofs when proving multiple elements because shared siblings
    /// are deduplicated.
    ///
    /// Positions are sorted internally; duplicate positions will return an error.
    pub fn multi_proof(&self, positions: &[u32]) -> Result<Proof<H::Digest>, Error> {
        // Handle empty positions first - can't prove zero elements
        if positions.is_empty() {
            return Err(Error::NoLeaves);
        }

        // Handle empty tree case
        if self.empty {
            return Err(Error::InvalidPosition(positions[0]));
        }

        let leaf_count = self.levels.first().len().get() as u32;

        // Get required sibling positions (this validates positions and checks for duplicates)
        let sibling_positions =
            siblings_required_for_multi_proof(leaf_count, positions.iter().copied())?;

        // Collect sibling digests in order
        let siblings: Vec<H::Digest> = sibling_positions
            .iter()
            .map(|&(level, index)| self.levels[level][index])
            .collect();

        Ok(Proof {
            leaf_count,
            siblings,
        })
    }
}

/// A pair of sibling digests, one on the left boundary and one on the right boundary.
#[derive(Clone, Debug, Eq)]
pub struct Bounds<D: Digest> {
    /// The left sibling digest.
    pub left: Option<D>,

    /// The right sibling digest.
    pub right: Option<D>,
}

impl<D: Digest> PartialEq for Bounds<D> {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.right == other.right
    }
}

impl<D: Digest> Write for Bounds<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.left.write(writer);
        self.right.write(writer);
    }
}

impl<D: Digest> Read for Bounds<D> {
    type Cfg = ();

    fn read_cfg(reader: &mut impl Buf, _: &Self::Cfg) -> Result<Self, commonware_codec::Error> {
        Ok(Self {
            left: Option::<D>::read(reader)?,
            right: Option::<D>::read(reader)?,
        })
    }
}

impl<D: Digest> EncodeSize for Bounds<D> {
    fn encode_size(&self) -> usize {
        self.left.encode_size() + self.right.encode_size()
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for Bounds<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            left: u.arbitrary()?,
            right: u.arbitrary()?,
        })
    }
}

/// A Merkle range proof for a contiguous set of leaves in a Binary Merkle Tree.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RangeProof<D: Digest> {
    /// The number of leaves in the tree.
    ///
    /// This value is incorporated into the root hash during finalization,
    /// so modifying it will cause verification to fail (prevents malleability).
    pub leaf_count: u32,

    /// The sibling digests needed to prove all elements in the range.
    ///
    /// Organized by level, from leaves to root. Each level can have at most
    /// 2 siblings (one on the left boundary and one on the right boundary).
    pub siblings: Vec<Bounds<D>>,
}

impl<D: Digest> Default for RangeProof<D> {
    fn default() -> Self {
        Self {
            leaf_count: 0,
            siblings: vec![],
        }
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for RangeProof<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            leaf_count: u.arbitrary()?,
            siblings: u.arbitrary()?,
        })
    }
}

/// A node tracked during range proof verification.
struct Node<D: Digest> {
    position: usize,
    digest: D,
}

impl<D: Digest> RangeProof<D> {
    /// Verifies that a given range of `leaves` starting at `position` are included
    /// in a Binary Merkle Tree with `root` using the provided `hasher`.
    ///
    /// The proof contains the set of sibling digests needed to reconstruct
    /// the root for all elements in the range. The `leaf_count` stored in the
    /// proof is incorporated into the finalized root computation.
    pub fn verify<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        position: u32,
        leaves: &[D],
        root: &D,
    ) -> Result<(), Error> {
        // Handle empty tree case
        if position == 0 && leaves.is_empty() && self.siblings.is_empty() && self.leaf_count == 0 {
            // Compute finalized empty root: H(0 || empty_tree_root)
            let empty_tree_root = hasher.finalize();
            hasher.update(&0u32.to_be_bytes());
            hasher.update(&empty_tree_root);
            let finalized = hasher.finalize();
            if finalized == *root {
                return Ok(());
            } else {
                return Err(Error::InvalidProof(finalized.to_string(), root.to_string()));
            }
        }

        // Check that we have leaves and the position is valid
        if leaves.is_empty() {
            return Err(Error::NoLeaves);
        }
        if position.checked_add(leaves.len() as u32).is_none() {
            return Err(Error::InvalidPosition(position));
        }

        // Compute position-hashed leaves
        let mut nodes: Vec<Node<D>> = Vec::new();
        for (i, leaf) in leaves.iter().enumerate() {
            let leaf_position = position + i as u32;
            hasher.update(&leaf_position.to_be_bytes());
            hasher.update(leaf);
            nodes.push(Node {
                position: leaf_position as usize,
                digest: hasher.finalize(),
            });
        }

        // Process each level
        for bounds in self.siblings.iter() {
            // Check if we should have a left sibling
            let first_pos = nodes[0].position;
            let last_pos = nodes[nodes.len() - 1].position;
            let needs_left = !first_pos.is_multiple_of(2);
            let needs_right = last_pos.is_multiple_of(2);
            if needs_left != bounds.left.is_some() {
                return Err(Error::UnalignedProof);
            }
            if needs_right != bounds.right.is_some() {
                return Err(Error::UnalignedProof);
            }

            // If we have a left sibling, we need to include it
            let mut i = 0;
            let mut next_nodes = Vec::new();
            if let Some(left) = &bounds.left {
                // The first node in our range needs its left sibling
                let node = &nodes[0];
                hasher.update(left);
                hasher.update(&node.digest);
                next_nodes.push(Node {
                    position: node.position / 2,
                    digest: hasher.finalize(),
                });
                i = 1;
            }

            // Process pairs of nodes in our range
            while i < nodes.len() {
                // Compute the parent position
                let node = &nodes[i];
                let parent_pos = node.position / 2;

                // Check if we have a pair within our range
                if i + 1 < nodes.len() && nodes[i + 1].position == node.position + 1 {
                    // We have both children in our range
                    hasher.update(&node.digest);
                    hasher.update(&nodes[i + 1].digest);
                    next_nodes.push(Node {
                        position: parent_pos,
                        digest: hasher.finalize(),
                    });
                    i += 2;
                } else if i == nodes.len() - 1 {
                    // This is the last node and it should have a right sibling
                    let right = bounds.right.as_ref().ok_or(Error::UnalignedProof)?;
                    hasher.update(&node.digest);
                    hasher.update(right);
                    next_nodes.push(Node {
                        position: parent_pos,
                        digest: hasher.finalize(),
                    });
                    i += 1;
                } else {
                    // Single node in the middle (shouldn't happen for contiguous range)
                    return Err(Error::UnalignedProof);
                }
            }

            nodes = next_nodes;
        }

        // Verify we ended up with the expected root
        if nodes.len() != 1 {
            return Err(Error::UnalignedProof);
        }

        // Finalize the root by incorporating the leaf count: H(leaf_count || tree_root)
        // This binds the proof to the specific tree size, preventing malleability attacks.
        let tree_root = nodes[0].digest;
        hasher.update(&self.leaf_count.to_be_bytes());
        hasher.update(&tree_root);
        let finalized = hasher.finalize();

        if finalized == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(finalized.to_string(), root.to_string()))
        }
    }
}

impl<D: Digest> Write for RangeProof<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.leaf_count.write(writer);
        self.siblings.write(writer);
    }
}

impl<D: Digest> Read for RangeProof<D> {
    type Cfg = ();

    fn read_cfg(reader: &mut impl Buf, _: &Self::Cfg) -> Result<Self, commonware_codec::Error> {
        let leaf_count = u32::read(reader)?;
        let siblings = Vec::<Bounds<D>>::read_range(reader, ..=MAX_LEVELS)?;
        Ok(Self {
            leaf_count,
            siblings,
        })
    }
}

impl<D: Digest> EncodeSize for RangeProof<D> {
    fn encode_size(&self) -> usize {
        self.leaf_count.encode_size() + self.siblings.encode_size()
    }
}

/// A Merkle proof for multiple non-contiguous leaves in a Binary Merkle Tree.
///
/// This proof type is more space-efficient than generating individual proofs
/// for each leaf because sibling nodes that are shared between multiple paths
/// are deduplicated.
///
/// The proof contains the leaf count and sibling digests required for verification.
/// The leaf count is incorporated into the root hash during finalization, so
/// modifying it will cause verification to fail (preventing malleability attacks).
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Proof<D: Digest> {
    /// The number of leaves in the tree.
    ///
    /// This value is incorporated into the root hash during finalization,
    /// so modifying it will cause verification to fail (prevents malleability).
    pub leaf_count: u32,

    /// The deduplicated sibling digests required to verify all elements,
    /// ordered by their position in the tree (level-major, then index within level).
    pub siblings: Vec<D>,
}

impl<D: Digest> Default for Proof<D> {
    fn default() -> Self {
        Self {
            leaf_count: 0,
            siblings: Vec::new(),
        }
    }
}

impl<D: Digest> Write for Proof<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.leaf_count.write(writer);
        self.siblings.write(writer);
    }
}

impl<D: Digest> Read for Proof<D> {
    /// The maximum number of items being proven.
    ///
    /// The upper bound on sibling hashes is derived as `max_items * MAX_LEVELS`.
    type Cfg = usize;

    fn read_cfg(
        reader: &mut impl Buf,
        max_items: &Self::Cfg,
    ) -> Result<Self, commonware_codec::Error> {
        let leaf_count = u32::read(reader)?;
        let max_siblings = max_items.saturating_mul(MAX_LEVELS);
        let siblings = Vec::<D>::read_range(reader, ..=max_siblings)?;
        Ok(Self {
            leaf_count,
            siblings,
        })
    }
}

impl<D: Digest> EncodeSize for Proof<D> {
    fn encode_size(&self) -> usize {
        self.leaf_count.encode_size() + self.siblings.encode_size()
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for Proof<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            leaf_count: u.arbitrary()?,
            siblings: u.arbitrary()?,
        })
    }
}

/// Returns the number of levels in a tree with `leaf_count` leaves.
/// A tree with 1 leaf has 1 level, a tree with 2 leaves has 2 levels, etc.
const fn levels_in_tree(leaf_count: u32) -> usize {
    (u32::BITS - (leaf_count.saturating_sub(1)).leading_zeros() + 1) as usize
}

/// Returns the sorted, deduplicated positions of siblings required to prove
/// inclusion of leaves at the given positions.
///
/// Each position in the result is encoded as `(level, index)` where level 0 is the leaf level.
fn siblings_required_for_multi_proof(
    leaf_count: u32,
    positions: impl IntoIterator<Item = u32>,
) -> Result<BTreeSet<(usize, usize)>, Error> {
    // Validate positions and check for duplicates.
    let mut current = BTreeSet::new();
    for pos in positions {
        if pos >= leaf_count {
            return Err(Error::InvalidPosition(pos));
        }
        if !current.insert(pos as usize) {
            return Err(Error::DuplicatePosition(pos));
        }
    }

    if current.is_empty() {
        return Err(Error::NoLeaves);
    }

    // Track positions we can compute at each level and record missing siblings.
    // This keeps the work proportional to the number of positions, not the tree size.
    let mut sibling_positions = BTreeSet::new();
    let levels_count = levels_in_tree(leaf_count);
    let mut level_size = leaf_count as usize;
    for level in 0..levels_count - 1 {
        for &index in &current {
            let sibling_index = if index.is_multiple_of(2) {
                if index + 1 < level_size {
                    index + 1
                } else {
                    index
                }
            } else {
                index - 1
            };

            if sibling_index != index && !current.contains(&sibling_index) {
                sibling_positions.insert((level, sibling_index));
            }
        }

        current = current.iter().map(|idx| idx / 2).collect();
        level_size = level_size.div_ceil(2);
    }

    Ok(sibling_positions)
}

impl<D: Digest> Proof<D> {
    /// Verifies that a given `leaf` at `position` is included in a Binary Merkle Tree
    /// with `root` using the provided `hasher`.
    ///
    /// The proof consists of sibling hashes stored from the leaf up to the root. At each
    /// level, if the current node is a left child (even index), the sibling is combined
    /// to the right; if it is a right child (odd index), the sibling is combined to the
    /// left.
    ///
    /// The `leaf_count` stored in the proof is incorporated into the finalized root
    /// computation, so any modification to it will cause verification to fail.
    pub fn verify_element_inclusion<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        leaf: &D,
        mut position: u32,
        root: &D,
    ) -> Result<(), Error> {
        // Validate position
        if position >= self.leaf_count {
            return Err(Error::InvalidPosition(position));
        }

        // Compute the position-hashed leaf
        hasher.update(&position.to_be_bytes());
        hasher.update(leaf);
        let mut computed = hasher.finalize();

        // Track level size to handle odd-sized levels
        let mut level_size = self.leaf_count as usize;
        let mut sibling_iter = self.siblings.iter();

        // Traverse from leaf to root
        while level_size > 1 {
            // Check if this is the last node at an odd-sized level (no real sibling)
            let is_last_odd = position.is_multiple_of(2) && position as usize + 1 >= level_size;

            let (left_node, right_node) = if is_last_odd {
                // Node is duplicated - no sibling consumed from proof
                (&computed, &computed)
            } else if position.is_multiple_of(2) {
                // Even position: sibling is to the right
                let sibling = sibling_iter.next().ok_or(Error::UnalignedProof)?;
                (&computed, sibling)
            } else {
                // Odd position: sibling is to the left
                let sibling = sibling_iter.next().ok_or(Error::UnalignedProof)?;
                (sibling, &computed)
            };

            // Compute the parent digest
            hasher.update(left_node);
            hasher.update(right_node);
            computed = hasher.finalize();

            // Move up the tree
            position /= 2;
            level_size = level_size.div_ceil(2);
        }

        // Ensure all siblings were consumed
        if sibling_iter.next().is_some() {
            return Err(Error::UnalignedProof);
        }

        // Finalize the root by incorporating the leaf count: H(leaf_count || tree_root)
        // This binds the proof to the specific tree size, preventing malleability attacks.
        hasher.update(&self.leaf_count.to_be_bytes());
        hasher.update(&computed);
        let finalized = hasher.finalize();

        if finalized == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(finalized.to_string(), root.to_string()))
        }
    }

    /// Verifies that the given `elements` at their respective positions are included
    /// in a Binary Merkle Tree with `root`.
    ///
    /// Elements can be provided in any order; positions are sorted internally.
    /// Duplicate positions will cause verification to fail.
    ///
    /// The `leaf_count` stored in the proof is incorporated into the finalized root
    /// computation, so any modification to it will cause verification to fail.
    pub fn verify_multi_inclusion<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        elements: &[(D, u32)],
        root: &D,
    ) -> Result<(), Error> {
        // Handle empty case
        if elements.is_empty() {
            if self.leaf_count == 0 && self.siblings.is_empty() {
                // Compute finalized empty root: H(0 || empty_tree_root)
                let empty_tree_root = hasher.finalize();
                hasher.update(&0u32.to_be_bytes());
                hasher.update(&empty_tree_root);
                let finalized = hasher.finalize();
                if finalized == *root {
                    return Ok(());
                } else {
                    return Err(Error::InvalidProof(finalized.to_string(), root.to_string()));
                }
            }
            return Err(Error::NoLeaves);
        }

        // 1. Sort elements by position and check for duplicates/bounds
        let mut sorted: Vec<(u32, D)> = Vec::with_capacity(elements.len());
        for (leaf, position) in elements {
            if *position >= self.leaf_count {
                return Err(Error::InvalidPosition(*position));
            }
            hasher.update(&position.to_be_bytes());
            hasher.update(leaf);
            sorted.push((*position, hasher.finalize()));
        }
        sorted.sort_unstable_by_key(|(pos, _)| *pos);

        // Check for duplicates (adjacent elements with same position after sorting)
        for i in 1..sorted.len() {
            if sorted[i - 1].0 == sorted[i].0 {
                return Err(Error::DuplicatePosition(sorted[i].0));
            }
        }

        // 2. Iterate up the tree
        // Since we process left-to-right and parent_pos = pos/2, next_level stays sorted.
        let levels = levels_in_tree(self.leaf_count);
        let mut level_size = self.leaf_count;
        let mut sibling_iter = self.siblings.iter();
        let mut current = sorted;
        let mut next_level: Vec<(u32, D)> = Vec::with_capacity(current.len());

        for _ in 0..levels - 1 {
            let mut idx = 0;
            while idx < current.len() {
                let (pos, digest) = current[idx];
                let parent_pos = pos / 2;

                // Determine if we have the left or right child
                let (left, right) = if pos % 2 == 0 {
                    // We are the LEFT child
                    let left = digest;

                    // Check if we have the right child in our current set
                    let right = if idx + 1 < current.len() && current[idx + 1].0 == pos + 1 {
                        idx += 1;
                        current[idx].1
                    } else if pos + 1 >= level_size {
                        // If no right child exists in tree, duplicate left
                        left
                    } else {
                        // Otherwise, must consume a sibling
                        *sibling_iter.next().ok_or(Error::UnalignedProof)?
                    };
                    (left, right)
                } else {
                    // We are the RIGHT child
                    // This implies the LEFT child was missing from 'current', so it must be a sibling.
                    let right = digest;
                    let left = *sibling_iter.next().ok_or(Error::UnalignedProof)?;
                    (left, right)
                };

                // Hash parent
                hasher.update(&left);
                hasher.update(&right);
                next_level.push((parent_pos, hasher.finalize()));

                idx += 1;
            }

            // Prepare for next level
            core::mem::swap(&mut current, &mut next_level);
            next_level.clear();
            level_size = level_size.div_ceil(2);
        }

        // 3. Verify root
        if sibling_iter.next().is_some() {
            return Err(Error::UnalignedProof);
        }

        if current.len() != 1 {
            return Err(Error::UnalignedProof);
        }

        // Finalize the root by incorporating the leaf count: H(leaf_count || tree_root)
        // This binds the proof to the specific tree size, preventing malleability attacks.
        let tree_root = current[0].1;
        hasher.update(&self.leaf_count.to_be_bytes());
        hasher.update(&tree_root);
        let finalized = hasher.finalize();

        if finalized == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(finalized.to_string(), root.to_string()))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use commonware_codec::{Decode, DecodeExt, Encode};
    use commonware_cryptography::sha256::{Digest, Sha256};
    use commonware_utils::hex;
    use rstest::rstest;

    fn test_merkle_tree(n: usize) -> Digest {
        // Build tree
        let mut digests = Vec::with_capacity(n);
        let mut builder = Builder::<Sha256>::new(n);
        for i in 0..n {
            let digest = Sha256::hash(&i.to_be_bytes());
            builder.add(&digest);
            digests.push(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // For each leaf, generate and verify its proof
        let mut hasher = Sha256::default();
        for (i, leaf) in digests.iter().enumerate() {
            // Generate proof
            let proof = tree.proof(i as u32).unwrap();
            assert!(
                proof
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_ok(),
                "correct fail for size={n} leaf={i}"
            );

            // Serialize and deserialize the proof
            let serialized = proof.encode();
            let deserialized = Proof::<Digest>::decode_cfg(serialized, &1).unwrap();
            assert!(
                deserialized
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_ok(),
                "deserialize fail for size={n} leaf={i}"
            );

            // Modify a sibling hash and ensure the proof fails
            if !proof.siblings.is_empty() {
                let mut update_tamper = proof.clone();
                update_tamper.siblings[0] = Sha256::hash(b"tampered");
                assert!(
                    update_tamper
                        .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                        .is_err(),
                    "modify fail for size={n} leaf={i}"
                );
            }

            // Add a sibling hash and ensure the proof fails
            let mut add_tamper = proof.clone();
            add_tamper.siblings.push(Sha256::hash(b"tampered"));
            assert!(
                add_tamper
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_err(),
                "add fail for size={n} leaf={i}"
            );

            // Remove a sibling hash and ensure the proof fails
            if !proof.siblings.is_empty() {
                let mut remove_tamper = proof.clone();
                remove_tamper.siblings.pop();
                assert!(
                    remove_tamper
                        .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                        .is_err(),
                    "remove fail for size={n} leaf={i}"
                );
            }
        }

        // Test proof for larger than size
        assert!(tree.proof(n as u32).is_err());

        // Return the root so we can ensure we don't silently change.
        root
    }

    /// Roots for all trees with 1..201 leaves.
    ///
    /// We use these pre-generated roots to ensure that we don't silently change
    /// the tree hashing algorithm.
    const ROOTS: [&str; 200] = [
        "d4f280154cb1f1ecee668774e73759cdff911f869b36bb77a89b2e1d91166e63",
        "49eb31cf6e99e84a30da2fe199a79b1ef9e8a8cc5061b358eac0f6822b1a582d",
        "78cdd53559a0d0822a5c4af3b143529e174e19967a4f579bde39dbc1f66d4420",
        "f61386f20c2b9e49a1d032a995294e5dfeb612fbe8773172738e6f6517c51f7f",
        "0ef54945b96bb989d59c24cf8359f2f821c91ecf01bd8c0e8a6667278a854e3c",
        "ec04f03f188991abaf76ffe24f638d3936207e64dcb190ff2b70a556688beaf7",
        "6dc72654e26208776695f87c27e3ab5b106a84336643a4cfed6765b44613aa62",
        "6c5cfad509cf32a935acf77ceb9611d6ce284e92fbf3f452c1dede368a8ddf2c",
        "e5b313dfb0eef7b53b5896e1ddcbf20390f4edcc6c133ba3fa28ab3411339253",
        "c235e179cb6dba95d2bb000f30013fec73687429c2e0a6eb9b59c36846fe4f32",
        "ccc2249929283c023fb8f87ea5d245e6efe31440f4783f1b1c47aa014bf69a5b",
        "29153085e8efd34e3c29e6fbd1f0a3354abf2c296284c98d34488f18a46b065b",
        "2a889d5140e90dbbb0c5a7131d4cef1b5c459da2e7db4d24741e1d8c56909fd9",
        "9b480acd294042eb7a026b01c86f5855a5d32b12c5bef8836367ee94f7b5de7f",
        "8c8842612ff7a98b5897aae460f79b57b0ef0636541ef17fe9c61629b129eff1",
        "c19a4d3726c7a4a5e9d40bb81b0424caccb5101aed9cd0d91e780d5e8d7b9ac9",
        "153d9045971c0ddcbed8998f7ca1fc4e7c85ec13a7695d069b670cf1d7169c9e",
        "77641b8b812970b5dfc4fd31493dd77f989478ac0c03a0151de7b97eec13b45e",
        "4fbc04115cab3156308816443aee0bc045bed2089418f7d76e3b63b3f2301bd6",
        "6e48f38c54ec52767086a247c0c819c5ef413a90e39a925fe4696b43d895960c",
        "678ff39a9df039ffc3f9b58f1d74dab5ce881dec3afe9c64b198843f4924ac03",
        "a705bb0f3c79b7e648b209d6fb2ef8f9706009f8364f2b1c2f2cf0f348921d26",
        "daa0c2529cca214a7d549b51de60b0fce9e9980f47de9c136730889523f19e27",
        "578c7132afac2bd4ff1835bfcd39e1c0940810bb1124da79154713b143ec01dc",
        "00766f07e7c4d74bf8279d70db068e156862cfd91c1e4bfaf115ef6fa50ebf70",
        "d470e3b4a8a4aee0c4db97ee42a583059c51819fd2dae984ee3992ee4d96c684",
        "5c79ad4e4c6ef5d0b6d2ec9097a4046a642f91eb394f6c4b5fb31e818364b103",
        "1a76fea7ca134c48bc47f77a7c87b431058b22221b43bdf930a2b5bb8f7a4cfe",
        "8846fa767b90e814478a91094d4e03f805ef910d93d3da7e273b393de561f3de",
        "74e2d9f327b16b79848c524d7d17290f78ee136a72035da14efc3d88fad38e95",
        "6d1c730c07c9014cf9afa329114cb9360d63299e1860ed21f5aebcbdaed64e75",
        "1a65d457d6946e6ff08e4cbeb05d39ff3fec4ffbba06a4a7d6a70fba9369bf48",
        "8d4c71679bbb53616d168f5ab96af26f6c8b4dddc7b1574d9852a7a951b0482b",
        "f1c2cd18449247a77ee8baee0a359a0070237a12ae82ce2fde083a5ca42411ad",
        "28aedcc544689a3a4713ad25a1f818af9eae1960b15e9b114a196caeff4ac3d8",
        "f37359e58340e0d0294f425660822d0784a240de6695285aaf0b0ba2cef1f39c",
        "7933c45e35c605e8052af0b8f87cf75c499ac9dca26db4e0129356bd3689f1b7",
        "fae6624afad6754705d8c727491f1622eb15f2dd9c0a7650f855f0ff1d84d035",
        "be0e69747cbe2ad8d198d41f4e588e33b2a7ff36565cd75559ddf2d84a1c3fe9",
        "9043ac05b5edfde35f624ccfeb42ad44d1a7112cdc84272ad572c62b53a3bb77",
        "e2f6040efee59b9ad46452a7a9f4ee9af5163d02ffbd4cc4aca6991cd143b9cd",
        "524bd1843f424f5a8cda2fc36a623f8f7de5bc68755f5e1b9eba3a3f62d63296",
        "3a8f5804264df9733385bd1298c3c4a04184eaf39115df083ae633562f70bfd9",
        "7267fee6c69aa0181ee8b8051e908efc57b8df85e84eff19ddd118b216697697",
        "fab9cfeb6831388e60d7e10b26636b087939fa412d92f8a509e77cf9ec6adf65",
        "1c0bcdea1f6e1e1af45b68d25f0152322d608703c36df4e57909bf7bb6554e90",
        "0a7db9b6c8cdc201697ca55e1c7e9bafba2e900081109cf6d4829e58bc14a695",
        "b3a1b089263ac76ed50844d3c64a1f4937ab14bfcc0685646aee7ccb4ea318cc",
        "be0c22acf8b839c502ae049bfae9ad03a7757752920d82a67a3b522b7a79c82c",
        "52ee8aa8bca662340af6b0a7b0c64e77a334ac8ef0b0f63ce2674dad30941d0a",
        "25bb4f6bca6d21c9b6b53a7e2529a777789b3782f6469482a35cf3644740a273",
        "53bdd051d27fb68dc524b8228019c4322409aecb991329e2ef384c60cfe6d87b",
        "678d58818688e6ef3444601c81d9d9a8ef02ec25e0a191139803493ed496f77f",
        "f479b07b8508d0e45eaf70bee826b10bc6e8bc715155c436407299ce4a2c321b",
        "949f76d20c0d59aed03dff08246355d5666f6f761f3cad68a0669f5f3788c686",
        "c602d363512440d4f375b487c88e95a05074d9060cd17b606f681bdb9bf8a19d",
        "bc85cb09b143be5536a6889e627aab62409f0c262b2eaab57f7b28aba9ace224",
        "bce6083c903f155e48c1efd15f916370495c2e9eeb0c855ec799d19d002cb1be",
        "5f0597e3b4d55a68cc821d8731acab246a40b37e55543f2ffa59d70669970e94",
        "9752cc102c7964eb2b64d721234656136a76c978bdcc51a886983cd57ccf4b8c",
        "3f0c288cd23bb9a20b16348c103a5f426a9277cc3b54f9adf47e6957ae0bdd05",
        "db67b59572e6ba03c2f524596a33429607587074f7144524e289f097267c1739",
        "459127dab0f651c14fd0b71771eaec1c2d133ad6d6d370fe58612a5eabd19558",
        "bc17e9bdac731cacab945855ac81c362aa19d9b6d028a15e3c030baab1566805",
        "e3d8c4786c7b549b16f45b871584804dae2289eb4e3b2129dccd5962c60ceaa8",
        "40354595385edc65b39cb5b24e4f082ee99f5d737ada3459b9ed81f9838f88fc",
        "731d52909d1776ae8cc73fffd3ca1bbdeab68128e3774924f494303c05d65679",
        "80d3487c3c186b7a3b02473d05b4e1f468be8ba8cd55b6ae8b35a43cb473e0f8",
        "b9570afc095c5ce90a71203006a9dd80e54eda40c43c29f7e677380763289b9a",
        "b8818f3964ba26ea1c318214bfd70fff435b814c30952302f9bb9988de6d6dbd",
        "702d1cbaf8e4920c0ac0a46c45a60807861cd2815e943509adf1df933f34fcb1",
        "1292dd4a853daffea69cc5e6bc2bebffdbf7b876a750c776c726522c4a73a56e",
        "7f8a4257c66b04a98ee26cc0f1cd1c5d69b043c5a1e1db449296eef43e409ad0",
        "a0305cee470d0ca78c670ee9a3075e909222007dd0623557b2932ea11683fe67",
        "c7ccae4d5d01f2a16ec6062f2b111d546e8c973d0f5bea3711e7bf42002c4260",
        "1304353512063770571faaa1e29211817690f580f112dc36b2fa57f564e1bd14",
        "0d112f3f59c3a516472e3fcc34219faa17db73f7e5299ab94348254f6770e411",
        "d2b322a4963964916134831912782b05b228d30b3097916cd6f52e5e662bc63a",
        "1c87729c6ac2a99bde7512bc25eae7d19b6f68821eb47288e8eb927ee093b574",
        "03506ba987786daeaabc6a86e62f2be7fc51a3fc334567127ad7073e04578052",
        "dbc7c27b68a16066b0431d2a8ecb3a7750f308897d09198502e32d6848672427",
        "0838f94353d483ba75b76fc529a1e4cb6b9f604df47bc32c9a473f055fa9dd0b",
        "68c9068b53c664f07cae3662879e8b4875a5aaa0165f2e790bec6e99321192f0",
        "a77649abbdbec69e040ba3fe8e18e148b8df150d166ac700b92c39122bcc687e",
        "8e05cc9c558e8fd876efd91ea6d6298da4f91aa9f3df4c09809399fae2a06ade",
        "f50935033be22737aac503795f56eedc00de6264063cdcbd5ddf61401051e22a",
        "c2be2030f8177ae55e5ba2956e867fa8e41bb3fd4907fabb66034f522c3ee7fd",
        "aa13755b991b1cc90b3350a6653962c76ab84bed4adbab019620fdf9f59b1b14",
        "1725d79eb9587ac7569cf1370b1cf29498e98fe6f37bae1741d71b14d6fd2812",
        "f783b97411c348a3f4b4a8d7cff138f4a2ed912a89d345a940d2afec96b41adb",
        "dba9ad886b1ddea67a8dfa02e3949d50d9cc1978d48bef10aba07e5a67be08cd",
        "3ba64712f1b7237d45147ad14863251eb6344ade5929daeeced8e29342be6a04",
        "a1b37505959bb2897103cb55f67c9cf52438bae47c6d87fac2da68f127fe2d8c",
        "fa7e940545cd9a426cdfb298b0fd93c49b2fd68f5a9b48b4959b67ad19e6f8e8",
        "2caf0fa574e7c67a1c92e0b866c4ec3f30adc3e3a0992a12cafa84c055bc7c8b",
        "12a76944e167b770a88301e932d9b6284cb8d0d3bafd29134e474916b7d9cab6",
        "c1f84fc54d3de64802b9eacdff1699fec99f4c30c43f04bd0b5a707ef7b9ae92",
        "271aa9152d04c7dd3a13cfc2f3387afbfea50359a65407a8f8f77bb01e09a158",
        "d275eaea7c0250cc6c8522f7d5c820c9a44851b26da85a36cb9e45cfccf308b0",
        "d1e4a3152673bcd0317bb56e1e7d815a20ebe86c030f0ee96d68cb2ad250fe55",
        "292a265db32f74f0d98974d9ab77ff9d9842bddc2292b97bf62d9750ec718f71",
        "cbbc4404c7cd3b97e95aeccabf302a964901aa869d60f89ca39da1cdda823870",
        "c76d06eafe044ad842f2b15970b461d1bee8441550e834cb0f9423706b79cdcf",
        "63ce8f2b4e1032ece0802799d7330f33107e1e1bb80c0c6bfa6f2a5b3c5c64b8",
        "601600b1148ed40009f5fa72a38dbb0dcbc0356728ae8ab543e9e55f68f9e06a",
        "cb03fd4422305f81b8d47f37d9f49996d84239fd4f8843faec3ae4a7baaa2fe6",
        "971fd864a795cdfab36f57e195f4fa263f09fea93b46903bea5997030b378924",
        "4682a35ca519c54333eaa0abbe32abcc989f1eb06dba18cd752bd0e1ea276a2f",
        "96526ed396d88070dcbf955c8dbd33ccc772ece53d62332a98e0368f70f009bf",
        "fc7bdac00670b9a9179c2b1c08d1970148b6a65d155949cce7c738a7bd320b71",
        "3845ba6bb0ab926894a10ef34f7ca146586d25543591e483b32a0b4e9e54e476",
        "a8fbfc8bdcc68eea293f8cfc15f3f6c5ff4532cc52ef2a5ab4db2ede950f519b",
        "945e5a20a24b76d8e34053a8c8f1d89df99d528e85431d167036b937dba64093",
        "075f36d6f505ea675c9a15337ac0e5d42c7ac46cfdca99a2f1c8de0557120143",
        "e3f2ac15cd8b4c8c21ea010a32449160836e4bc17a6f2d232a06bdfd88f5224e",
        "5d6faf62feedb9f52861e827d236cec356918f435382057a2c5ad77977edbbda",
        "f626c97be870f1524519414489f4297c6d50fa52246641f56b8c355a38f4edbd",
        "a397ffc981d2a18ebf794ece94a27563f0d70828c229dd313e0d1fd8c60e7809",
        "ba38f67a6e41e2b8ed9042dfd7703272ec4ff88ad7f5ac2d03c336a70a3156a0",
        "abc08d989967e041750f6f12ccae092c98937b3e25cf20c3e5b4c93da6c229b0",
        "0c6e896cb9270730e65d4922b6de957a9437ce53199e06326fd8db5cba550c93",
        "2bee732c3a018bcc319080cbc98518bfe9546f7c6adb4dbf725e74558fec7df6",
        "60d9cee1983df813e74d1ac97816d3d90170e0c3e4a22ac6195a3668b1a93aa0",
        "e174efd6697e6a489edbbce40375f2a679d500d6c31904b9ef17a18028ed4b2b",
        "aaf684876bd1a9082385b5aeddea2f1853cd339898c8ade152deabc7dfcb4d43",
        "48d5bca111002716d508edb88deb356285f8b23e969c223b5dddcdacc47cb43f",
        "6aec40d5627011fcd9b74ab688d999d1e5f952a338a696f899558b980b59fd99",
        "0a6341a8c30497ebd024a6735cf7feeae04c357c1480e69708455b70e518a23a",
        "23fcf1054353045d6fd756f63128ac1196c7140d3e3f18824b3eeba64487e023",
        "c60edf7bb55ecb88f486aa5ae84f3a21f90a396a128a8a02940d4d4506399b89",
        "73b9bb14c5f3ce04efc8c7832de4223ff8a1dbdbc8313e6d83404340add208ba",
        "d8624c0261e55a1092a79a7a63dc2eaebba87e9a02eeac308bb556fd4e97a993",
        "c2af564397e21891696c264e203c8a3f97c47bb1637a9d9fcf789668188a83a6",
        "f1b3a41f6f790513ca229353f80118fd9cb80447439f8921d0e3ab4fe0f2e03f",
        "14897c923416162ae387e79d633b0d0e661db62dc9d07d07b76fc5be8837a2e8",
        "e048b4e7b9709abedc656457f3e9e649917223279f211a530615f2cf00a1326f",
        "076b9c52c94fa0ffd7c307dad42fe564672706a0785c9fe39568da77d30e070c",
        "bba9332370a3a770a8406097073caa965bc214c06b1ce248851e2d6c0e177410",
        "bd127fde91807496aa015793f95ba325222d03994358419f70d8dce434afb127",
        "f703dbc474d597d4c6f981c0559d4487e4cd9684dffa1d578104d787ecfceae9",
        "beb70ae814a53ea099054e9dff3e088675397973e7fbeb040243ee31cce3c59a",
        "ea5bd419364e8ca7a0f5ea57b75dd32acbda0d8e9988bd9ca51793c027be0251",
        "702f08d219f0fcf2dcd46df1abc35d9032c0b77d08cddb03c0fe9fee5c35f539",
        "e726220fbd8807a30630b97006a221c2fb3be5b76ce176a2f68ef772a555f73c",
        "aa6b97c8d5f7950a9d69774f221cbe568a368e4ab59df5684e6a06458088f1f1",
        "05453f64cdc8a0c841e6d499d63448a56090b471546703dac09c5f2cf2dfbb9f",
        "7e651dd0701e295f1a9c781ce86894c7907ee8f7571158c39e23654d9a652fb7",
        "60c09037adfaf895527a82ff50171019a628345f35ba29419f3f05ce754b2966",
        "3714e7751d2df63008e7f859868858b4bc529105610107c16ed42e7ffd8a54c7",
        "d5fa81cd1b8608b4cb27f166c8df1aa227e169f45fb17b1d5a6b1b06052541ba",
        "e9c0bdc50209de7ddedc3bb2897b68ef0220c8cfcb5e44ed622a4797322380cc",
        "7bef152e4394469c95c7473e4169698a674ec1b088f88e85123aa5549dcf4ed3",
        "aaa587323cf3a6ab32dd0ae6a7d46968ec895678ad8b3c7689f1a2fa1b917fa2",
        "260b5e58e7774407a2ad5b0d19c9c2a56043a5078be5d354a52e2790244e7dd6",
        "2f259df83a8c6305ccaa89452b14f71b736ef522bcb6f7aa7b02ce11eb1125a8",
        "a3825df2637a9359badd732d240073093e50573d99ae1dacd2acc60249eaa81d",
        "b089b29a5c86a47c0a4bb3748e41feebc1dc57b1ce0ff414db57dc8b44b676b6",
        "09f72bd4c92fb95a2353a8e0689dd7f246f8d113f1eac24c3a95e027182326af",
        "fd1c2447195ff2897d98d9ec24b3c171aec16cbee19f35efe21e6571888b63e9",
        "601ab0d0c77868cce2fdcf0dc3bba0b45d4b1bd8164d42318535225e8d924b31",
        "f59c99ae73784ee3761f6e180fd645dbe96dbdff428a583fb98b3c111e7999ad",
        "af7d8811d034332b890b20cccf778313158989177ce3f4e2b73b624be6a6426d",
        "f57b09af5d340c5b8224ddad9414ec7be4ed7ed9d4350d26e434a9b56da26eea",
        "712ac3a6425de43133016a01f3e904ec3c9ad21c01a33cf83ee750fd0ec6c257",
        "5ea0e60e548feec8ea79dd9109de4f699d9a6fc33912db63441b047901bbd83f",
        "ba91828e2dafc44d32e93bd8746494a91ae1d183b3489d050709fc8076a8ed19",
        "e4e296d1f0ceec43982a9dead5be2c402909ed494d92e5b327e703ac48a82b43",
        "b45d7aa6c26b6203f3baa6d2b179c0dc87864df165fc1d7e65d19e790c2a9d3f",
        "ca61bacfede356e5d6a4631b46b90b1c98a857b2f21c45813aaf42abfb6e0860",
        "5f0307281aefa937b0662306201a2a873a1cd0d37cbca5c18228086f427060d1",
        "956fd70c558a415d00cef508b10150ab6db5c26702d658d3c47749d4fc44842d",
        "c889f94566c5005cb6c67d1d494fb9ca3d4fa7c2bfa78ce37e070cdf3bd971ef",
        "76dc3062f09039773857624e23c3bf851b0fe3f18d1858b997af8c6f0886cda7",
        "2fd1630bdcc98e7e25021491d855b8af2d8dd1a7f206bf8c65922630e70b2b7f",
        "5461f7518a99bd09fca7228c3065fd3187b2c4d41a2f4042579bd530e79b0298",
        "247f5ab9870cbfee426cdf6fbe7ae1babdfc922b614ed8596d63d97ef3eb24d9",
        "2696548b0a078f8ae90d4a2bd11366cbd07eda761f987483eb52f6cf90ae7dd3",
        "cf2d6b1f35d858c7ce8934e7007d9fc2d37a11e7117942d4576a12f206d4f8f6",
        "5a60c561c5a1798cf16a5e02d5c431bf7f863bab5e52608e92c70376330a1542",
        "5f7d94438d6a6577c9dec752c9fd83925da7fcdae224c9d0ffd6cd6cdc5dd97e",
        "fef74eeb4c2e2eda502cb128531f8bfc0539506dcc1d660d788f419218f7e1d3",
        "3ca18d8b3978dffb90bb001c4aefc990c4a984a3fe3f310ca565d51312a052a0",
        "8341132efaf765511907a3ec9bac18962dc5fe4aa7cbec4789f785aad3afe9d9",
        "3ae8f7967c6c2425cdb44cf656098dfebbecf5df80958c148d6e9e00ae2b5c35",
        "d8de28d88d9740619695c322ae1315e057c6cae4acc3b962bb97cde93624708e",
        "7d01d1f0eaaa943eaf0b511dd3bd3f3abb67db51bc592a780f6d7d0c7942e985",
        "a204cd0186945bfdcd02d5246324a341fe296bdc2322617705d2f4b94314a90f",
        "5c42d151927e5572449d20889704bfefe8d0655a942054baae6e413ee575dfd5",
        "e8504bcab82300315026c289ce6a3e1fcfdf87bab8757ae6fdc26d57c96c2061",
        "baa8c48f205ef3c1e19199d369ce739b7ba511fae1aa6602a2bb56808d0031ca",
        "f7418e4cb4f5535a810f4969e6212bea5db25b2b19648ef46bd038f14e78297d",
        "2da1f73594945de360727681c4f8906de9d58624b27aec4c30884c2fbe2ace61",
        "6c48693e166e45dbd32c5f1a45faec50c25a184ac9dd3d843bf50fbf44eb1c9b",
        "c7afd63324a5924b689eea5ef51d74183fd2bbf41c19636cc25efc87d87d059e",
        "f1e78086083a4d922e8e1bac062a127a9df84d2d95d54d5549197c9afb8975a4",
        "a72b98d9c43745d9bd058ec0678bccafc3218e1a583650cde69724deb7bb0b58",
        "12d8f2319a19d87c585d9836f0099923d09d3b1803ad7830f09ba58f35a797d4",
        "cbedec8fb4a9867fa1f16ab8993bccb084ddaf31693b5720fdd7014ebe2e802a",
        "6642ec4dac36a6e23885c0012a6fb07da170e727e46b9fc3acccf1d0f53251f3",
        "69eb1916c8369e31e39aaf328a00985757e5a2497ee903a2245e16c02ecd231b",
    ];

    #[test]
    fn test_merkle_trees() {
        for (n, previous) in ROOTS.into_iter().enumerate() {
            let root = test_merkle_tree(n);
            assert_eq!(hex(&root), previous);
        }
    }

    /// Regression test for https://github.com/commonwarexyz/monorepo/issues/2837
    ///
    /// Before the fix, two proofs with identical siblings but different leaf_count
    /// values would both verify successfully against the same root, enabling
    /// proof malleability attacks.
    #[test]
    fn test_leaf_count_malleability_rejected() {
        // Create a tree with 255 leaves (as in the issue report)
        let digests: Vec<Digest> = (0..255u32)
            .map(|i| Sha256::hash(&i.to_be_bytes()))
            .collect();

        let mut builder = Builder::<Sha256>::new(255);
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get a valid proof for position 0
        let original_proof = tree.proof(0).unwrap();
        assert_eq!(original_proof.leaf_count, 255);

        // Original proof should verify
        let mut hasher = Sha256::default();
        assert!(
            original_proof
                .verify_element_inclusion(&mut hasher, &digests[0], 0, &root)
                .is_ok(),
            "Original proof should verify"
        );

        // Create a malleated proof with leaf_count=254 but same siblings
        // (This is the exact attack from issue #2837)
        let malleated_proof = Proof {
            leaf_count: 254,
            siblings: original_proof.siblings.clone(),
        };

        // Malleated proof should NOT verify because the root now incorporates
        // the leaf_count: root = H(leaf_count || tree_root)
        let result = malleated_proof.verify_element_inclusion(&mut hasher, &digests[0], 0, &root);
        assert!(
            result.is_err(),
            "Malleated proof with wrong leaf_count must fail verification"
        );
    }

    #[test]
    fn test_tampered_proof_no_siblings() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
        let element = &digests[0];

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Build proof
        let mut proof = tree.proof(0).unwrap();

        // Tamper with proof
        proof.siblings = Vec::new();

        // Fail verification with an empty proof.
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, element, 0, &root)
            .is_err());
    }

    #[test]
    fn test_tampered_proof_extra_sibling() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
        let element = &digests[0];

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Build proof
        let mut proof = tree.proof(0).unwrap();

        // Tamper with proof
        proof.siblings.push(*element);

        // Fail verification with extra sibling
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, element, 0, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_element() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 2.
        let proof = tree.proof(2).unwrap();

        // Use a wrong element (e.g. hash of a different transaction).
        let mut hasher = Sha256::default();
        let wrong_leaf = Sha256::hash(b"wrong_tx");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &wrong_leaf, 2, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_index() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();

        // Use an incorrect index (e.g. 2 instead of 1).
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[1], 2, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_root() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 0.
        let proof = tree.proof(0).unwrap();

        // Use a wrong root (hash of a different input).
        let mut hasher = Sha256::default();
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[0], 0, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_serialization_truncated() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();
        let mut serialized = proof.encode();

        // Truncate one byte.
        serialized.truncate(serialized.len() - 1);
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &1).is_err());
    }

    #[test]
    fn test_invalid_proof_serialization_extra() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();
        let mut serialized = proof.encode_mut();

        // Append an extra byte.
        serialized.extend_from_slice(&[0u8]);
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &1).is_err());
    }

    #[test]
    fn test_invalid_proof_modified_hash() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 2.
        let mut proof = tree.proof(2).unwrap();

        // Modify the first hash in the proof.
        let mut hasher = Sha256::default();
        proof.siblings[0] = Sha256::hash(b"modified");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 2, &root)
            .is_err());
    }

    #[test]
    fn test_odd_tree_duplicate_index_proof() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // The tree was built with 3 leaves; index 2 is the last valid index.
        let proof = tree.proof(2).unwrap();

        // Verification should succeed for the proper index 2.
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 2, &root)
            .is_ok());

        // Should not be able to generate a proof for an out-of-range index (e.g. 3).
        assert!(tree.proof(3).is_err());

        // Attempting to verify using an out-of-range index (e.g. 3, which would correspond
        // to a duplicate leaf that doesn't actually exist) should fail.
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 3, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_basic() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test range proof for elements 2-5
        let range_proof = tree.range_proof(2, 5).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..6];

        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_ok());

        // Serialize and deserialize
        let mut serialized = range_proof.encode();
        let deserialized = RangeProof::<Digest>::decode(&mut serialized).unwrap();
        assert!(deserialized
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_ok());
    }

    #[test]
    fn test_range_proof_single_element() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test single element range proof
        for (i, digest) in digests.iter().enumerate() {
            let range_proof = tree.range_proof(i as u32, i as u32).unwrap();
            let mut hasher = Sha256::default();

            let result = range_proof.verify(&mut hasher, i as u32, &[*digest], &root);
            assert!(result.is_ok());
        }
    }

    #[test]
    fn test_range_proof_full_tree() {
        // Create test data
        let digests: Vec<Digest> = (0..7u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test full tree range proof
        let range_proof = tree.range_proof(0, (digests.len() - 1) as u32).unwrap();
        let mut hasher = Sha256::default();
        assert!(range_proof.verify(&mut hasher, 0, &digests, &root).is_ok());
    }

    #[test]
    fn test_range_proof_edge_cases() {
        // Create test data
        let digests: Vec<Digest> = (0..15u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test first half
        let range_proof = tree.range_proof(0, 7).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 0, &digests[0..8], &root)
            .is_ok());

        // Test second half
        let range_proof = tree.range_proof(8, 14).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 8, &digests[8..15], &root)
            .is_ok());

        // Test last elements
        let range_proof = tree.range_proof(13, 14).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 13, &digests[13..15], &root)
            .is_ok());
    }

    #[test]
    fn test_range_proof_invalid_range() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test invalid ranges
        assert!(tree.range_proof(8, 8).is_err()); // Start out of bounds
        assert!(tree.range_proof(0, 8).is_err()); // End out of bounds
        assert!(tree.range_proof(5, 8).is_err()); // End out of bounds
        assert!(tree.range_proof(2, 1).is_err()); // Start > end
    }

    #[test]
    fn test_range_proof_tampering() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..5];

        // Test with wrong leaves
        let wrong_leaves = vec![
            Sha256::hash(b"wrong1"),
            Sha256::hash(b"wrong2"),
            Sha256::hash(b"wrong3"),
        ];
        assert!(range_proof
            .verify(&mut hasher, 2, &wrong_leaves, &root)
            .is_err());

        // Test with wrong number of leaves
        assert!(range_proof
            .verify(&mut hasher, 2, &digests[2..4], &root)
            .is_err());

        // Test with tampered proof
        let mut tampered_proof = range_proof.clone();
        assert!(!tampered_proof.siblings.is_empty());
        // Tamper with the first level's left sibling if it exists
        if let Some(ref mut left) = tampered_proof.siblings[0].left {
            *left = Sha256::hash(b"tampered");
        } else if let Some(ref mut right) = tampered_proof.siblings[0].right {
            *right = Sha256::hash(b"tampered");
        }
        assert!(tampered_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());

        // Test with wrong root
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_range_proof_various_sizes() {
        // Test range proofs for trees of various sizes
        for tree_size in [1, 2, 3, 4, 5, 7, 8, 15, 16, 31, 32, 63, 64] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_be_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test various range sizes
            for range_size in 1..=tree_size.min(8) {
                for start in 0..=(tree_size - range_size) {
                    let range_proof = tree
                        .range_proof(start as u32, (start + range_size - 1) as u32)
                        .unwrap();
                    let end = start + range_size;
                    assert!(
                        range_proof
                            .verify(&mut hasher, start as u32, &digests[start..end], &root)
                            .is_ok(),
                        "Failed for tree_size={tree_size}, start={start}, range_size={range_size}"
                    );
                }
            }
        }
    }

    #[test]
    fn test_range_proof_malicious_wrong_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for position 2 to 4
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..5];

        // Try to verify with wrong position
        assert!(range_proof
            .verify(&mut hasher, 3, range_leaves, &root)
            .is_err());
        assert!(range_proof
            .verify(&mut hasher, 1, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_reordered_leaves() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for position 2 to 4
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();

        // Try to verify with reordered leaves
        let reordered_leaves = vec![digests[3], digests[2], digests[4]];
        assert!(range_proof
            .verify(&mut hasher, 2, &reordered_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_extra_siblings() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let mut range_proof = tree.range_proof(2, 3).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..4];

        // Tamper by setting both siblings when there should only be one or two
        assert!(!range_proof.siblings.is_empty());
        // Force an invalid state by modifying the siblings
        if range_proof.siblings[0].left.is_none() {
            range_proof.siblings[0].left = Some(Sha256::hash(b"extra"));
        } else if range_proof.siblings[0].right.is_none() {
            range_proof.siblings[0].right = Some(Sha256::hash(b"extra"));
        }
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_missing_siblings() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for a single element (which needs siblings)
        let mut range_proof = tree.range_proof(2, 2).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..3];

        // The proof should have siblings at the first level
        assert!(!range_proof.siblings.is_empty());
        assert!(range_proof.siblings[0].left.is_some() || range_proof.siblings[0].right.is_some());

        // Remove a sibling from a level
        range_proof.siblings[0].left = None;
        range_proof.siblings[0].right = None;
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_integer_overflow_protection() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test overflow in range_proof generation
        assert!(tree.range_proof(u32::MAX, u32::MAX).is_err());
        assert!(tree.range_proof(u32::MAX - 1, u32::MAX).is_err());
        assert!(tree.range_proof(7, u32::MAX).is_err());
    }

    #[test]
    fn test_range_proof_malicious_wrong_tree_structure() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let mut range_proof = tree.range_proof(2, 3).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..4];

        // Add extra level (simulating proof from different tree structure)
        range_proof.siblings.push(Bounds {
            left: Some(Sha256::hash(b"fake_level")),
            right: None,
        });
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());

        // Remove a level
        let mut range_proof = tree.range_proof(2, 2).unwrap();
        assert!(!range_proof.siblings.is_empty());
        range_proof.siblings.pop();
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_boundary_conditions() {
        // Test various power-of-2 boundary conditions
        for tree_size in [1, 2, 4, 8, 16, 32] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_be_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test edge cases
            // First element only
            let proof = tree.range_proof(0, 0).unwrap();
            assert!(proof.verify(&mut hasher, 0, &digests[0..1], &root).is_ok());

            // Last element only
            let last_idx = tree_size - 1;
            let proof = tree.range_proof(last_idx as u32, last_idx as u32).unwrap();
            assert!(proof
                .verify(
                    &mut hasher,
                    last_idx as u32,
                    &digests[last_idx..tree_size],
                    &root
                )
                .is_ok());

            // Full tree
            let proof = tree.range_proof(0, (tree_size - 1) as u32).unwrap();
            assert!(proof.verify(&mut hasher, 0, &digests, &root).is_ok());
        }
    }

    #[test]
    fn test_empty_tree_proof() {
        // Build an empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();

        // Empty tree should fail for any position since there are no elements
        assert!(tree.proof(0).is_err());
        assert!(tree.proof(1).is_err());
        assert!(tree.proof(100).is_err());
    }

    #[test]
    fn test_empty_tree_range_proof() {
        // Build an empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();
        let root = tree.root();

        // Empty tree should return default range proof only for (0, 0)
        let range_proof = tree.range_proof(0, 0).unwrap();
        assert!(range_proof.siblings.is_empty());
        assert_eq!(range_proof, RangeProof::default());

        // All other combinations should fail
        let invalid_ranges = vec![
            (0, 1),
            (0, 10),
            (1, 1),
            (1, 2),
            (5, 5),
            (10, 10),
            (0, u32::MAX),
            (u32::MAX, u32::MAX),
        ];
        for (start, end) in invalid_ranges {
            assert!(tree.range_proof(start, end).is_err());
        }

        // Verify empty range proof against empty tree root
        let mut hasher = Sha256::default();
        let empty_leaves: &[Digest] = &[];
        assert!(range_proof
            .verify(&mut hasher, 0, empty_leaves, &root)
            .is_ok());

        // Should fail with non-empty leaves
        let non_empty_leaves = vec![Sha256::hash(b"leaf")];
        assert!(range_proof
            .verify(&mut hasher, 0, &non_empty_leaves, &root)
            .is_err());

        // Should fail with wrong root
        let wrong_root = Sha256::hash(b"wrong");
        assert!(range_proof
            .verify(&mut hasher, 0, empty_leaves, &wrong_root)
            .is_err());

        // Should fail with wrong position
        assert!(range_proof
            .verify(&mut hasher, 1, empty_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_empty_range_proof_serialization() {
        let range_proof = RangeProof::<Digest>::default();
        let mut serialized = range_proof.encode();
        let deserialized = RangeProof::<Digest>::decode(&mut serialized).unwrap();
        assert_eq!(range_proof, deserialized);
    }

    #[test]
    fn test_empty_tree_root_consistency() {
        // Create multiple empty trees and verify they have the same root
        let mut roots = Vec::new();
        for _ in 0..5 {
            let builder = Builder::<Sha256>::new(0);
            let tree = builder.build();
            roots.push(tree.root());
        }

        // All empty trees should have the same root
        for i in 1..roots.len() {
            assert_eq!(roots[0], roots[i]);
        }

        // The root should be the hash of empty data
        let mut hasher = Sha256::default();
        hasher.update(0u32.to_be_bytes().as_slice());
        hasher.update(Sha256::hash(b"").as_ref());
        let expected_root = hasher.finalize();
        assert_eq!(roots[0], expected_root);
    }

    #[rstest]
    #[case::need_left_sibling(1, 2)] // Range starting at odd index (needs left sibling)
    #[case::need_right_sibling(4, 4)] // Range starting at even index ending at odd (needs right sibling)
    #[case::boundaries_both_single_children(4, 4)] // Range with both boundaries needing siblings
    #[case::full_tree(0, 16)] // Full tree (no siblings needed at leaf level)
    fn test_range_proof_bounds_usage(#[case] start: u32, #[case] count: u32) {
        // This test ensures that all bounds in a range proof are actually used during verification
        // and that we don't have unnecessary siblings
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        let range_proof = tree.range_proof(start, start + count - 1).unwrap();
        let end = start as usize + count as usize;

        // Verify the proof works
        assert!(range_proof
            .verify(&mut hasher, start, &digests[start as usize..end], &root)
            .is_ok());

        // For each level with siblings, try removing them and verify the proof fails
        for level_idx in 0..range_proof.siblings.len() {
            let bounds = &range_proof.siblings[level_idx];

            // If there's a left sibling, removing it should make the proof fail
            if bounds.left.is_some() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].left = None;
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's a right sibling, removing it should make the proof fail
            if bounds.right.is_some() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].right = None;
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's no left sibling, adding one should make the proof fail
            if bounds.left.is_none() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].left = Some(Sha256::hash(b"fake_left"));
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's no right sibling, adding one should make the proof fail
            if bounds.right.is_none() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].right = Some(Sha256::hash(b"fake_right"));
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }
        }
    }

    // Test trees with odd sizes that require duplicate nodes
    #[rstest]
    fn test_range_proof_duplicate_node_edge_cases(
        #[values(3, 5, 7, 9, 11, 13, 15)] tree_size: usize,
    ) {
        let digests: Vec<Digest> = (0..tree_size as u32)
            .map(|i| Sha256::hash(&i.to_be_bytes()))
            .collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test range including the last element (which may require duplicate handling)
        let start = tree_size - 2;
        let proof = tree
            .range_proof(start as u32, (tree_size - 1) as u32)
            .unwrap();
        assert!(proof
            .verify(&mut hasher, start as u32, &digests[start..tree_size], &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_basic() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test multi-proof for non-contiguous positions [0, 3, 5]
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();
        let mut hasher = Sha256::default();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_single_element() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test single element multi-proof for each position
        for (i, digest) in digests.iter().enumerate() {
            let multi_proof = tree.multi_proof(&[i as u32]).unwrap();
            let elements = [(*digest, i as u32)];
            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_ok(),
                "Failed for position {i}"
            );
        }
    }

    #[test]
    fn test_multi_proof_all_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test multi-proof for all elements
        let positions: Vec<u32> = (0..digests.len() as u32).collect();
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());

        // When proving all elements, we shouldn't need any siblings (all can be computed)
        assert!(multi_proof.siblings.is_empty());
    }

    #[test]
    fn test_multi_proof_adjacent_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test adjacent positions (should deduplicate shared siblings)
        let positions = [2, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_sparse_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test widely separated positions
        let positions = [0, 7, 8, 15];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_empty_tree() {
        // Build empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();

        // Empty tree with empty positions should return NoLeaves error
        // (we can't prove zero elements)
        assert!(matches!(tree.multi_proof(&[]), Err(Error::NoLeaves)));

        // Empty tree with any position should fail with InvalidPosition
        assert!(matches!(
            tree.multi_proof(&[0]),
            Err(Error::InvalidPosition(0))
        ));
    }

    #[test]
    fn test_multi_proof_empty_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Empty positions should return error
        assert!(matches!(tree.multi_proof(&[]), Err(Error::NoLeaves)));
    }

    #[test]
    fn test_multi_proof_duplicate_positions_error() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Duplicate positions should return error
        assert!(matches!(
            tree.multi_proof(&[1, 1]),
            Err(Error::DuplicatePosition(1))
        ));
        assert!(matches!(
            tree.multi_proof(&[0, 2, 2, 5]),
            Err(Error::DuplicatePosition(2))
        ));
    }

    #[test]
    fn test_multi_proof_unsorted_input() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test with unsorted positions (should work - internal sorting)
        let positions = [5, 0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with unsorted elements (should work - internal sorting)
        let unsorted_elements = [(digests[5], 5), (digests[0], 0), (digests[3], 3)];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &unsorted_elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_various_sizes() {
        // Test multi-proofs for trees of various sizes
        for tree_size in [1, 2, 3, 4, 5, 7, 8, 15, 16, 31, 32] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_be_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test various position combinations
            // First and last
            if tree_size >= 2 {
                let positions = [0, (tree_size - 1) as u32];
                let multi_proof = tree.multi_proof(&positions).unwrap();
                let elements: Vec<(Digest, u32)> = positions
                    .iter()
                    .map(|&p| (digests[p as usize], p))
                    .collect();
                assert!(
                    multi_proof
                        .verify_multi_inclusion(&mut hasher, &elements, &root)
                        .is_ok(),
                    "Failed for tree_size={tree_size}, positions=[0, {}]",
                    tree_size - 1
                );
            }

            // Every other element
            if tree_size >= 4 {
                let positions: Vec<u32> = (0..tree_size as u32).step_by(2).collect();
                let multi_proof = tree.multi_proof(&positions).unwrap();
                let elements: Vec<(Digest, u32)> = positions
                    .iter()
                    .map(|&p| (digests[p as usize], p))
                    .collect();
                assert!(
                    multi_proof
                        .verify_multi_inclusion(&mut hasher, &elements, &root)
                        .is_ok(),
                    "Failed for tree_size={tree_size}, every other element"
                );
            }
        }
    }

    #[test]
    fn test_multi_proof_wrong_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with wrong elements
        let wrong_elements = [
            (Sha256::hash(b"wrong1"), 0),
            (digests[3], 3),
            (digests[5], 5),
        ];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &wrong_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_wrong_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with wrong positions (same elements, different positions)
        let wrong_positions = [
            (digests[0], 1), // wrong position
            (digests[3], 3),
            (digests[5], 5),
        ];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &wrong_positions, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_wrong_root() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Verify with wrong root
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_tampering() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Tamper with sibling
        assert!(!multi_proof.siblings.is_empty());
        let mut modified = multi_proof.clone();
        modified.siblings[0] = Sha256::hash(b"tampered");
        assert!(modified
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());

        // Add extra sibling
        let mut extra = multi_proof.clone();
        extra.siblings.push(Sha256::hash(b"extra"));
        assert!(extra
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());

        // Remove a sibling
        let mut missing = multi_proof;
        missing.siblings.pop();
        assert!(missing
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_deduplication() {
        // Create test data
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Get individual proofs
        let individual_siblings: usize = [0u32, 1, 8, 9]
            .iter()
            .map(|&p| tree.proof(p).unwrap().siblings.len())
            .sum();

        // Get multi-proof for same positions
        let multi_proof = tree.multi_proof(&[0, 1, 8, 9]).unwrap();

        // Multi-proof should have fewer siblings due to deduplication
        assert!(
            multi_proof.siblings.len() < individual_siblings,
            "Multi-proof ({}) should have fewer siblings than sum of individual proofs ({})",
            multi_proof.siblings.len(),
            individual_siblings
        );
    }

    #[test]
    fn test_multi_proof_serialization() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and deserialize
        let serialized = multi_proof.encode();
        let deserialized = Proof::<Digest>::decode_cfg(serialized, &positions.len()).unwrap();

        assert_eq!(multi_proof, deserialized);

        // Verify deserialized proof works
        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(deserialized
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_serialization_truncated() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and truncate
        let mut serialized = multi_proof.encode();
        serialized.truncate(serialized.len() - 1);

        // Should fail to deserialize
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &positions.len()).is_err());
    }

    #[test]
    fn test_multi_proof_serialization_extra() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and add extra byte
        let mut serialized = multi_proof.encode_mut();
        serialized.extend_from_slice(&[0u8]);

        // Should fail to deserialize
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &positions.len()).is_err());
    }

    #[test]
    fn test_multi_proof_decode_insufficient_data() {
        let mut serialized = Vec::new();
        serialized.extend_from_slice(&8u32.encode()); // leaf_count
        serialized.extend_from_slice(&1usize.encode()); // claims 1 sibling but no data follows

        // Should fail because the buffer claims 1 sibling but doesn't have the data
        let err = Proof::<Digest>::decode_cfg(serialized.as_slice(), &1).unwrap_err();
        assert!(matches!(err, commonware_codec::Error::EndOfBuffer));
    }

    #[test]
    fn test_multi_proof_invalid_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test out of bounds position
        assert!(matches!(
            tree.multi_proof(&[0, 8]),
            Err(Error::InvalidPosition(8))
        ));
        assert!(matches!(
            tree.multi_proof(&[100]),
            Err(Error::InvalidPosition(100))
        ));
    }

    #[test]
    fn test_multi_proof_verify_invalid_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with out of bounds position
        let invalid_elements = [(digests[0], 0), (digests[3], 100)];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &invalid_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_odd_tree_sizes() {
        // Test odd-sized trees that require node duplication
        for tree_size in [3, 5, 7, 9, 11, 13, 15] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_be_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test with positions including the last element
            let positions = [0, (tree_size - 1) as u32];
            let multi_proof = tree.multi_proof(&positions).unwrap();

            let elements: Vec<(Digest, u32)> = positions
                .iter()
                .map(|&p| (digests[p as usize], p))
                .collect();
            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_ok(),
                "Failed for tree_size={tree_size}"
            );
        }
    }

    #[test]
    fn test_multi_proof_verify_empty_elements() {
        // Create a valid proof and try to verify with empty elements
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with empty elements
        let empty_elements: &[(Digest, u32)] = &[];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_default_verify() {
        // Default (empty) proof should only verify against empty tree
        let mut hasher = Sha256::default();
        let default_proof = Proof::<Digest>::default();

        // Empty elements against default proof
        let empty_elements: &[(Digest, u32)] = &[];

        // Build empty tree to get the empty root
        let builder = Builder::<Sha256>::new(0);
        let empty_tree = builder.build();
        let empty_root = empty_tree.root();

        assert!(default_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &empty_root)
            .is_ok());

        // Should fail with wrong root
        let wrong_root = Sha256::hash(b"not_empty");
        assert!(default_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_single_leaf_tree() {
        // Edge case: tree with exactly one leaf
        let digest = Sha256::hash(b"only_leaf");

        // Build single-leaf tree
        let mut builder = Builder::<Sha256>::new(1);
        builder.add(&digest);
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate multi-proof for the only leaf
        let multi_proof = tree.multi_proof(&[0]).unwrap();

        // Single leaf tree: leaf_count should be 1
        assert_eq!(multi_proof.leaf_count, 1);

        // Single leaf tree: no siblings needed (leaf is the root after position hashing)
        assert!(
            multi_proof.siblings.is_empty(),
            "Single leaf tree should have no siblings"
        );

        // Verify the proof
        let elements = [(digest, 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_ok(),
            "Single leaf multi-proof verification failed"
        );

        // Verify with wrong digest fails
        let wrong_digest = Sha256::hash(b"wrong");
        let wrong_elements = [(wrong_digest, 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &wrong_elements, &root)
                .is_err(),
            "Should fail with wrong digest"
        );

        // Verify with wrong position fails
        let wrong_position_elements = [(digest, 1u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &wrong_position_elements, &root)
                .is_err(),
            "Should fail with invalid position"
        );
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_zero() {
        // Attacker sets leaf_count = 0 but provides siblings
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and tamper with leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        multi_proof.leaf_count = 0;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - leaf_count=0 but we have elements
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_larger() {
        // Attacker inflates leaf_count to claim proof is for larger tree
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and inflate leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        let original_leaf_count = multi_proof.leaf_count;
        multi_proof.leaf_count = 1000;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - inflated leaf_count changes required siblings
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_err(),
            "Should reject proof with inflated leaf_count ({} -> {})",
            original_leaf_count,
            multi_proof.leaf_count
        );
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_smaller() {
        // Attacker deflates leaf_count to claim proof is for smaller tree
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and deflate leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        multi_proof.leaf_count = 4; // Smaller than actual tree

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - deflated leaf_count changes tree structure
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_err(),
            "Should reject proof with deflated leaf_count"
        );
    }

    #[test]
    fn test_multi_proof_mismatched_element_count() {
        // Provide more or fewer elements than the proof was generated for
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate proof for 2 positions
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with only 1 element (too few)
        let too_few = [(digests[0], 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &too_few, &root)
                .is_err(),
            "Should reject when fewer elements provided than proof was generated for"
        );

        // Try to verify with 3 elements (too many)
        let too_many = [(digests[0], 0u32), (digests[3], 3), (digests[5], 5)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &too_many, &root)
                .is_err(),
            "Should reject when more elements provided than proof was generated for"
        );
    }

    #[test]
    fn test_multi_proof_swapped_siblings() {
        // Swap the order of siblings in the proof
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof with multiple siblings
        let positions = [0, 5];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();

        // Ensure we have at least 2 siblings to swap
        if multi_proof.siblings.len() >= 2 {
            // Swap first two siblings
            multi_proof.siblings.swap(0, 1);

            let elements: Vec<(Digest, u32)> = positions
                .iter()
                .map(|&p| (digests[p as usize], p))
                .collect();

            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_err(),
                "Should reject proof with swapped siblings"
            );
        }
    }

    #[test]
    fn test_multi_proof_dos_large_leaf_count() {
        // Attacker sets massive leaf_count trying to cause DoS via memory allocation
        // The verify function should NOT allocate proportional to leaf_count
        let digests: Vec<Digest> = (0..4u32).map(|i| Sha256::hash(&i.to_be_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 2];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();

        // Set massive leaf_count (attacker trying to exhaust memory)
        multi_proof.leaf_count = u32::MAX;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // This should fail quickly without allocating massive memory
        // The function is O(elements * levels), not O(leaf_count)
        let result = multi_proof.verify_multi_inclusion(&mut hasher, &elements, &root);
        assert!(result.is_err(), "Should reject malicious large leaf_count");
    }

    #[cfg(feature = "arbitrary")]
    mod conformance {
        use super::*;
        use commonware_codec::conformance::CodecConformance;
        use commonware_cryptography::sha256::Digest as Sha256Digest;

        commonware_conformance::conformance_tests! {
            CodecConformance<RangeProof<Sha256Digest>>,
            CodecConformance<Bounds<Sha256Digest>>,
            CodecConformance<Proof<Sha256Digest>>,
        }
    }
}
