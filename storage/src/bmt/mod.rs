//! Stateless Binary Merkle Tree (BMT).
//!
//! The Binary Merkle Tree is constructed level-by-level. The first level consists of position-hashed leaf digests.
//! On each additional level, pairs of nodes are hashed from the previous level (if a level contains an odd
//! number of nodes, the last node is duplicated). The root of the tree is the digest of the node in the top level.
//!
//! For example, given three leaves A, B, and C, the tree is constructed as follows:
//!
//! ```text
//!     Level 2 (root):       [hash(hash(hash(0,A),hash(1,B)),hash(hash(2,C),hash(2,C)))]
//!     Level 1:              [hash(hash(0,A),hash(1,B)),hash(hash(2,C),hash(2,C))]
//!     Level 0 (leaves):     [hash(0,A),hash(1,B),hash(2,C)]
//! ```
//!
//! A proof for one or more leaves is generated by collecting the siblings needed to reconstruct the root.
//! An external process can then use this proof (with some trusted root) to verify that the leaves
//! are part of the tree.
//!
//! # Example
//!
//! ```rust
//! use commonware_storage::bmt::{Builder, Tree};
//! use commonware_cryptography::{Sha256, sha256::Digest, Hasher as _};
//!
//! // Create transactions and compute their digests
//! let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
//! let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
//!
//! // Build a Merkle Tree from the digests
//! let mut builder = Builder::<Sha256>::new(digests.len());
//! for digest in &digests {
//!    builder.add(digest);
//! }
//! let tree = builder.build();
//! let root = tree.root();
//!
//! // Generate a proof for leaf at index 1
//! let mut hasher = Sha256::default();
//! let proof = tree.proof(1).unwrap();
//! assert!(proof.verify_element_inclusion(&mut hasher, &digests[1], 1, &root).is_ok());
//! ```

use alloc::collections::btree_set::BTreeSet;
use bytes::{Buf, BufMut};
use commonware_codec::{EncodeSize, Read, ReadExt, ReadRangeExt, Write};
use commonware_cryptography::{Digest, Hasher};
use commonware_utils::{non_empty_vec, vec::NonEmptyVec};
use thiserror::Error;

/// There should never be more than 255 levels in a proof (would mean the Binary Merkle Tree
/// has more than 2^255 leaves).
pub const MAX_LEVELS: usize = u8::MAX as usize;

/// Errors that can occur when working with a Binary Merkle Tree (BMT).
#[derive(Error, Debug)]
pub enum Error {
    #[error("invalid position: {0}")]
    InvalidPosition(u32),
    #[error("invalid proof: {0} != {1}")]
    InvalidProof(String, String),
    #[error("no leaves")]
    NoLeaves,
    #[error("unaligned proof")]
    UnalignedProof,
    #[error("duplicate position: {0}")]
    DuplicatePosition(u32),
}

/// Constructor for a Binary Merkle Tree (BMT).
pub struct Builder<H: Hasher> {
    hasher: H,
    leaves: Vec<H::Digest>,
}

impl<H: Hasher> Builder<H> {
    /// Creates a new Binary Merkle Tree builder.
    pub fn new(leaves: usize) -> Self {
        Self {
            hasher: H::new(),
            leaves: Vec::with_capacity(leaves),
        }
    }

    /// Adds a leaf to the Binary Merkle Tree.
    ///
    /// When added, the leaf is hashed with its position.
    pub fn add(&mut self, leaf: &H::Digest) -> u32 {
        let position: u32 = self.leaves.len().try_into().expect("too many leaves");
        self.hasher.update(&position.to_le_bytes());
        self.hasher.update(leaf);
        self.leaves.push(self.hasher.finalize());
        position
    }

    /// Builds the Binary Merkle Tree.
    ///
    /// It is valid to build a tree with no leaves, in which case
    /// just an "empty" node is included (no leaves will be provable).
    pub fn build(self) -> Tree<H> {
        Tree::new(self.hasher, self.leaves)
    }
}

/// Constructed Binary Merkle Tree (BMT).
#[derive(Clone, Debug)]
pub struct Tree<H: Hasher> {
    /// Records whether the tree is empty.
    empty: bool,

    /// The digests at each level of the tree (from leaves to root).
    levels: NonEmptyVec<NonEmptyVec<H::Digest>>,
}

impl<H: Hasher> Tree<H> {
    /// Builds a Merkle Tree from a slice of position-hashed leaf digests.
    fn new(mut hasher: H, mut leaves: Vec<H::Digest>) -> Self {
        // If no leaves, add an empty node.
        //
        // Because this node only includes a position, there is no way a valid proof
        // can be generated that references it.
        let mut empty = false;
        if leaves.is_empty() {
            leaves.push(hasher.finalize());
            empty = true;
        }

        // Create the first level
        let mut levels = non_empty_vec![non_empty_vec![@leaves]];

        // Construct the tree level-by-level
        let mut current_level = levels.last();
        while !current_level.is_singleton() {
            let mut next_level = Vec::with_capacity(current_level.len().get().div_ceil(2));
            for chunk in current_level.chunks(2) {
                // Hash the left child
                hasher.update(&chunk[0]);

                // Hash the right child
                if chunk.len() == 2 {
                    hasher.update(&chunk[1]);
                } else {
                    // If no right child exists, duplicate left child.
                    hasher.update(&chunk[0]);
                };

                // Compute the parent digest
                next_level.push(hasher.finalize());
            }

            // Add the computed level to the tree
            levels.push(non_empty_vec![@next_level]);
            current_level = levels.last();
        }
        Self { empty, levels }
    }

    /// Returns the root of the tree.
    pub fn root(&self) -> H::Digest {
        *self.levels.last().first()
    }

    /// Generates a Merkle proof for the leaf at `position`.
    ///
    /// This is a single-element multi-proof, which includes the minimal siblings
    /// needed to reconstruct the root.
    pub fn proof(&self, position: u32) -> Result<Proof<H::Digest>, Error> {
        self.multi_proof(&[position])
    }

    /// Generates a Merkle range proof for a contiguous set of leaves from `start`
    /// to `end` (inclusive).
    ///
    /// The proof contains the minimal set of sibling digests needed to reconstruct
    /// the root for all elements in the range. This is more efficient than individual
    /// proofs when proving multiple consecutive elements.
    pub fn range_proof(&self, start: u32, end: u32) -> Result<RangeProof<H::Digest>, Error> {
        // For empty trees, return an empty proof
        if self.empty && start == 0 && end == 0 {
            return Ok(RangeProof::default());
        }

        // Ensure the range is within bounds
        if start > end {
            return Err(Error::InvalidPosition(start));
        }
        let leaf_count = self.levels.first().len().get() as u32;
        if start >= leaf_count {
            return Err(Error::InvalidPosition(start));
        }
        if end >= leaf_count {
            return Err(Error::InvalidPosition(end));
        }

        // For each level (except the root level) collect the necessary siblings
        let mut siblings = Vec::new();
        for (level_idx, level) in self.levels.iter().enumerate() {
            // If the level has only one node, we're done
            if level.is_singleton() {
                break;
            }

            // Calculate the range of indices at this level
            let level_start = (start as usize) >> level_idx;
            let level_end = (end as usize) >> level_idx;

            // Check if we need a left sibling
            let mut left = None;
            if level_start % 2 == 1 {
                // Our range starts at an odd index, so we need the even sibling to the left
                left = Some(level[level_start - 1]);
            }

            // Check if we need a right sibling
            let mut right = None;
            if level_end.is_multiple_of(2) {
                if level_end + 1 < level.len().get() {
                    // Our range ends at an even index, so we need the odd sibling to the right
                    right = Some(level[level_end + 1]);
                } else {
                    // If no right child exists, use a duplicate of the current node.
                    //
                    // This doesn't affect the robustness of the proof (allow a non-existent position
                    // to be proven or enable multiple proofs to be generated from a single leaf).
                    right = Some(level[level_end]);
                }
            }

            siblings.push(Bounds { left, right });
        }

        Ok(RangeProof { siblings })
    }

    /// Generates a Merkle proof for multiple non-contiguous leaves at the given `positions`.
    ///
    /// The proof contains the minimal set of sibling digests needed to reconstruct
    /// the root for all elements at the specified positions. This is more efficient
    /// than individual proofs when proving multiple elements because shared siblings
    /// are deduplicated.
    ///
    /// Positions are sorted internally; duplicate positions will return an error.
    pub fn multi_proof(&self, positions: &[u32]) -> Result<Proof<H::Digest>, Error> {
        // Handle empty positions first - can't prove zero elements
        if positions.is_empty() {
            return Err(Error::NoLeaves);
        }

        // Handle empty tree case
        if self.empty {
            return Err(Error::InvalidPosition(positions[0]));
        }

        let leaf_count = self.levels.first().len().get() as u32;

        // Get required sibling positions (this validates positions and checks for duplicates)
        let sibling_positions =
            siblings_required_for_multi_proof(leaf_count, positions.iter().copied())?;

        // Collect sibling digests in order
        let siblings: Vec<H::Digest> = sibling_positions
            .iter()
            .map(|&(level, index)| self.levels[level][index])
            .collect();

        Ok(Proof {
            leaf_count,
            siblings,
        })
    }
}

/// A pair of sibling digests, one on the left boundary and one on the right boundary.
#[derive(Clone, Debug, Eq)]
pub struct Bounds<D: Digest> {
    /// The left sibling digest.
    pub left: Option<D>,

    /// The right sibling digest.
    pub right: Option<D>,
}

impl<D: Digest> PartialEq for Bounds<D> {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.right == other.right
    }
}

impl<D: Digest> Write for Bounds<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.left.write(writer);
        self.right.write(writer);
    }
}

impl<D: Digest> Read for Bounds<D> {
    type Cfg = ();

    fn read_cfg(reader: &mut impl Buf, _: &Self::Cfg) -> Result<Self, commonware_codec::Error> {
        Ok(Self {
            left: Option::<D>::read(reader)?,
            right: Option::<D>::read(reader)?,
        })
    }
}

impl<D: Digest> EncodeSize for Bounds<D> {
    fn encode_size(&self) -> usize {
        self.left.encode_size() + self.right.encode_size()
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for Bounds<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            left: u.arbitrary()?,
            right: u.arbitrary()?,
        })
    }
}

/// A Merkle range proof for a contiguous set of leaves in a Binary Merkle Tree.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RangeProof<D: Digest> {
    /// The sibling digests needed to prove all elements in the range.
    ///
    /// Organized by level, from leaves to root. Each level can have at most
    /// 2 siblings (one on the left boundary and one on the right boundary).
    pub siblings: Vec<Bounds<D>>,
}

impl<D: Digest> Default for RangeProof<D> {
    fn default() -> Self {
        Self { siblings: vec![] }
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for RangeProof<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            siblings: u.arbitrary()?,
        })
    }
}

/// A node tracked during range proof verification.
struct Node<D: Digest> {
    position: usize,
    digest: D,
}

impl<D: Digest> RangeProof<D> {
    /// Verifies that a given range of `leaves` starting at `position` are included
    /// in a Binary Merkle Tree with `root` using the provided `hasher`.
    ///
    /// The proof contains the set of sibling digests needed to reconstruct
    /// the root for all elements in the range.
    pub fn verify<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        position: u32,
        leaves: &[D],
        root: &D,
    ) -> Result<(), Error> {
        // Handle empty tree case
        if position == 0 && leaves.is_empty() && self.siblings.is_empty() {
            let empty_root = hasher.finalize();
            if empty_root == *root {
                return Ok(());
            } else {
                return Err(Error::InvalidProof(
                    empty_root.to_string(),
                    root.to_string(),
                ));
            }
        }

        // Check that we have leaves and the position is valid
        if leaves.is_empty() {
            return Err(Error::NoLeaves);
        }
        if position.checked_add(leaves.len() as u32).is_none() {
            return Err(Error::InvalidPosition(position));
        }

        // Compute position-hashed leaves
        let mut nodes: Vec<Node<D>> = Vec::new();
        for (i, leaf) in leaves.iter().enumerate() {
            let leaf_position = position + i as u32;
            hasher.update(&leaf_position.to_le_bytes());
            hasher.update(leaf);
            nodes.push(Node {
                position: leaf_position as usize,
                digest: hasher.finalize(),
            });
        }

        // Process each level
        for bounds in self.siblings.iter() {
            // Check if we should have a left sibling
            let first_pos = nodes[0].position;
            let last_pos = nodes[nodes.len() - 1].position;
            let needs_left = !first_pos.is_multiple_of(2);
            let needs_right = last_pos.is_multiple_of(2);
            if needs_left != bounds.left.is_some() {
                return Err(Error::UnalignedProof);
            }
            if needs_right != bounds.right.is_some() {
                return Err(Error::UnalignedProof);
            }

            // If we have a left sibling, we need to include it
            let mut i = 0;
            let mut next_nodes = Vec::new();
            if let Some(left) = &bounds.left {
                // The first node in our range needs its left sibling
                let node = &nodes[0];
                hasher.update(left);
                hasher.update(&node.digest);
                next_nodes.push(Node {
                    position: node.position / 2,
                    digest: hasher.finalize(),
                });
                i = 1;
            }

            // Process pairs of nodes in our range
            while i < nodes.len() {
                // Compute the parent position
                let node = &nodes[i];
                let parent_pos = node.position / 2;

                // Check if we have a pair within our range
                if i + 1 < nodes.len() && nodes[i + 1].position == node.position + 1 {
                    // We have both children in our range
                    hasher.update(&node.digest);
                    hasher.update(&nodes[i + 1].digest);
                    next_nodes.push(Node {
                        position: parent_pos,
                        digest: hasher.finalize(),
                    });
                    i += 2;
                } else if i == nodes.len() - 1 {
                    // This is the last node and it should have a right sibling
                    let right = bounds.right.as_ref().ok_or(Error::UnalignedProof)?;
                    hasher.update(&node.digest);
                    hasher.update(right);
                    next_nodes.push(Node {
                        position: parent_pos,
                        digest: hasher.finalize(),
                    });
                    i += 1;
                } else {
                    // Single node in the middle (shouldn't happen for contiguous range)
                    return Err(Error::UnalignedProof);
                }
            }

            nodes = next_nodes;
        }

        // Verify we ended up with the expected root
        if nodes.len() != 1 {
            return Err(Error::UnalignedProof);
        }
        let computed = nodes[0].digest;
        if computed == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(computed.to_string(), root.to_string()))
        }
    }
}

impl<D: Digest> Write for RangeProof<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.siblings.write(writer);
    }
}

impl<D: Digest> Read for RangeProof<D> {
    type Cfg = ();

    fn read_cfg(reader: &mut impl Buf, _: &Self::Cfg) -> Result<Self, commonware_codec::Error> {
        let siblings = Vec::<Bounds<D>>::read_range(reader, ..=MAX_LEVELS)?;
        Ok(Self { siblings })
    }
}

impl<D: Digest> EncodeSize for RangeProof<D> {
    fn encode_size(&self) -> usize {
        self.siblings.encode_size()
    }
}

/// A Merkle proof for multiple non-contiguous leaves in a Binary Merkle Tree.
///
/// This proof type is more space-efficient than generating individual proofs
/// for each leaf because sibling nodes that are shared between multiple paths
/// are deduplicated.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Proof<D: Digest> {
    /// The total number of leaves in the tree.
    pub leaf_count: u32,
    /// The deduplicated sibling digests required to verify all elements,
    /// ordered by their position in the tree (level-major, then index within level).
    pub siblings: Vec<D>,
}

impl<D: Digest> Default for Proof<D> {
    fn default() -> Self {
        Self {
            leaf_count: 0,
            siblings: vec![],
        }
    }
}

impl<D: Digest> Write for Proof<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.leaf_count.write(writer);
        self.siblings.write(writer);
    }
}

impl<D: Digest> Read for Proof<D> {
    /// The maximum number of items being proven.
    ///
    /// The upper bound on sibling hashes is derived as `max_items * MAX_LEVELS`.
    type Cfg = usize;

    fn read_cfg(
        reader: &mut impl Buf,
        max_items: &Self::Cfg,
    ) -> Result<Self, commonware_codec::Error> {
        let leaf_count = u32::read(reader)?;
        let max_siblings = max_items.saturating_mul(MAX_LEVELS);
        let siblings = Vec::<D>::read_range(reader, ..=max_siblings)?;
        Ok(Self {
            leaf_count,
            siblings,
        })
    }
}

impl<D: Digest> EncodeSize for Proof<D> {
    fn encode_size(&self) -> usize {
        self.leaf_count.encode_size() + self.siblings.encode_size()
    }
}

#[cfg(feature = "arbitrary")]
impl<D: Digest> arbitrary::Arbitrary<'_> for Proof<D>
where
    D: for<'a> arbitrary::Arbitrary<'a>,
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        Ok(Self {
            leaf_count: u.arbitrary()?,
            siblings: u.arbitrary()?,
        })
    }
}

/// Returns the number of levels in a tree with `leaf_count` leaves.
/// A tree with 1 leaf has 1 level, a tree with 2 leaves has 2 levels, etc.
const fn levels_in_tree(leaf_count: u32) -> usize {
    (u32::BITS - (leaf_count.saturating_sub(1)).leading_zeros() + 1) as usize
}

/// Returns the sorted, deduplicated positions of siblings required to prove
/// inclusion of leaves at the given positions.
///
/// Each position in the result is encoded as `(level, index)` where level 0 is the leaf level.
fn siblings_required_for_multi_proof(
    leaf_count: u32,
    positions: impl IntoIterator<Item = u32>,
) -> Result<BTreeSet<(usize, usize)>, Error> {
    // Validate positions and check for duplicates.
    let mut current = BTreeSet::new();
    for pos in positions {
        if pos >= leaf_count {
            return Err(Error::InvalidPosition(pos));
        }
        if !current.insert(pos as usize) {
            return Err(Error::DuplicatePosition(pos));
        }
    }

    if current.is_empty() {
        return Err(Error::NoLeaves);
    }

    // Track positions we can compute at each level and record missing siblings.
    // This keeps the work proportional to the number of positions, not the tree size.
    let mut sibling_positions = BTreeSet::new();
    let levels_count = levels_in_tree(leaf_count);
    let mut level_size = leaf_count as usize;
    for level in 0..levels_count - 1 {
        for &index in &current {
            let sibling_index = if index.is_multiple_of(2) {
                if index + 1 < level_size {
                    index + 1
                } else {
                    index
                }
            } else {
                index - 1
            };

            if sibling_index != index && !current.contains(&sibling_index) {
                sibling_positions.insert((level, sibling_index));
            }
        }

        current = current.iter().map(|idx| idx / 2).collect();
        level_size = level_size.div_ceil(2);
    }

    Ok(sibling_positions)
}

impl<D: Digest> Proof<D> {
    /// Verifies that a given `leaf` at `position` is included in a Binary Merkle Tree
    /// with `root` using the provided `hasher`.
    ///
    /// The proof consists of sibling hashes stored from the leaf up to the root. At each
    /// level, if the current node is a left child (even index), the sibling is combined
    /// to the right; if it is a right child (odd index), the sibling is combined to the
    /// left.
    pub fn verify_element_inclusion<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        leaf: &D,
        mut position: u32,
        root: &D,
    ) -> Result<(), Error> {
        // Validate position
        if position >= self.leaf_count {
            return Err(Error::InvalidPosition(position));
        }

        // Compute the position-hashed leaf
        hasher.update(&position.to_le_bytes());
        hasher.update(leaf);
        let mut computed = hasher.finalize();

        // Track level size to handle odd-sized levels
        let mut level_size = self.leaf_count as usize;
        let mut sibling_iter = self.siblings.iter();

        // Traverse from leaf to root
        while level_size > 1 {
            // Check if this is the last node at an odd-sized level (no real sibling)
            let is_last_odd = position.is_multiple_of(2) && position as usize + 1 >= level_size;

            let (left_node, right_node) = if is_last_odd {
                // Node is duplicated - no sibling consumed from proof
                (&computed, &computed)
            } else if position.is_multiple_of(2) {
                // Even position: sibling is to the right
                let sibling = sibling_iter.next().ok_or(Error::UnalignedProof)?;
                (&computed, sibling)
            } else {
                // Odd position: sibling is to the left
                let sibling = sibling_iter.next().ok_or(Error::UnalignedProof)?;
                (sibling, &computed)
            };

            // Compute the parent digest
            hasher.update(left_node);
            hasher.update(right_node);
            computed = hasher.finalize();

            // Move up the tree
            position /= 2;
            level_size = level_size.div_ceil(2);
        }

        // Ensure all siblings were consumed
        if sibling_iter.next().is_some() {
            return Err(Error::UnalignedProof);
        }

        if computed == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(computed.to_string(), root.to_string()))
        }
    }

    /// Verifies that the given `elements` at their respective positions are included
    /// in a Binary Merkle Tree with `root`.
    ///
    /// Elements can be provided in any order; positions are sorted internally.
    /// Duplicate positions will cause verification to fail.
    pub fn verify_multi_inclusion<H: Hasher<Digest = D>>(
        &self,
        hasher: &mut H,
        elements: &[(D, u32)],
        root: &D,
    ) -> Result<(), Error> {
        // Handle empty case
        if elements.is_empty() {
            if self.leaf_count == 0 && self.siblings.is_empty() {
                let empty_root = hasher.finalize();
                if empty_root == *root {
                    return Ok(());
                } else {
                    return Err(Error::InvalidProof(
                        empty_root.to_string(),
                        root.to_string(),
                    ));
                }
            }
            return Err(Error::NoLeaves);
        }

        // 1. Sort elements by position and check for duplicates/bounds
        let mut sorted: Vec<(u32, D)> = Vec::with_capacity(elements.len());
        for (leaf, position) in elements {
            if *position >= self.leaf_count {
                return Err(Error::InvalidPosition(*position));
            }
            hasher.update(&position.to_le_bytes());
            hasher.update(leaf);
            sorted.push((*position, hasher.finalize()));
        }
        sorted.sort_unstable_by_key(|(pos, _)| *pos);

        // Check for duplicates (adjacent elements with same position after sorting)
        for i in 1..sorted.len() {
            if sorted[i - 1].0 == sorted[i].0 {
                return Err(Error::DuplicatePosition(sorted[i].0));
            }
        }

        // 2. Iterate up the tree
        // Since we process left-to-right and parent_pos = pos/2, next_level stays sorted.
        let levels = levels_in_tree(self.leaf_count);
        let mut level_size = self.leaf_count;
        let mut sibling_iter = self.siblings.iter();
        let mut current = sorted;
        let mut next_level: Vec<(u32, D)> = Vec::with_capacity(current.len());

        for _ in 0..levels - 1 {
            let mut idx = 0;
            while idx < current.len() {
                let (pos, digest) = current[idx];
                let parent_pos = pos / 2;

                // Determine if we have the left or right child
                let (left, right) = if pos % 2 == 0 {
                    // We are the LEFT child
                    let left = digest;

                    // Check if we have the right child in our current set
                    let right = if idx + 1 < current.len() && current[idx + 1].0 == pos + 1 {
                        idx += 1;
                        current[idx].1
                    } else if pos + 1 >= level_size {
                        // If no right child exists in tree, duplicate left
                        left
                    } else {
                        // Otherwise, must consume a sibling
                        *sibling_iter.next().ok_or(Error::UnalignedProof)?
                    };
                    (left, right)
                } else {
                    // We are the RIGHT child
                    // This implies the LEFT child was missing from 'current', so it must be a sibling.
                    let right = digest;
                    let left = *sibling_iter.next().ok_or(Error::UnalignedProof)?;
                    (left, right)
                };

                // Hash parent
                hasher.update(&left);
                hasher.update(&right);
                next_level.push((parent_pos, hasher.finalize()));

                idx += 1;
            }

            // Prepare for next level
            core::mem::swap(&mut current, &mut next_level);
            next_level.clear();
            level_size = level_size.div_ceil(2);
        }

        // 3. Verify root
        if sibling_iter.next().is_some() {
            return Err(Error::UnalignedProof);
        }

        if current.len() != 1 {
            return Err(Error::UnalignedProof);
        }

        let computed = current[0].1;
        if computed == *root {
            Ok(())
        } else {
            Err(Error::InvalidProof(computed.to_string(), root.to_string()))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use commonware_codec::{Decode, DecodeExt, Encode};
    use commonware_cryptography::sha256::{Digest, Sha256};
    use commonware_utils::hex;
    use rstest::rstest;

    fn test_merkle_tree(n: usize) -> Digest {
        // Build tree
        let mut digests = Vec::with_capacity(n);
        let mut builder = Builder::<Sha256>::new(n);
        for i in 0..n {
            let digest = Sha256::hash(&i.to_le_bytes());
            builder.add(&digest);
            digests.push(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // For each leaf, generate and verify its proof
        let mut hasher = Sha256::default();
        for (i, leaf) in digests.iter().enumerate() {
            // Generate proof
            let proof = tree.proof(i as u32).unwrap();
            assert!(
                proof
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_ok(),
                "correct fail for size={n} leaf={i}"
            );

            // Serialize and deserialize the proof
            let serialized = proof.encode();
            let deserialized = Proof::<Digest>::decode_cfg(serialized, &1).unwrap();
            assert!(
                deserialized
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_ok(),
                "deserialize fail for size={n} leaf={i}"
            );

            // Modify a sibling hash and ensure the proof fails
            if !proof.siblings.is_empty() {
                let mut update_tamper = proof.clone();
                update_tamper.siblings[0] = Sha256::hash(b"tampered");
                assert!(
                    update_tamper
                        .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                        .is_err(),
                    "modify fail for size={n} leaf={i}"
                );
            }

            // Add a sibling hash and ensure the proof fails
            let mut add_tamper = proof.clone();
            add_tamper.siblings.push(Sha256::hash(b"tampered"));
            assert!(
                add_tamper
                    .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                    .is_err(),
                "add fail for size={n} leaf={i}"
            );

            // Remove a sibling hash and ensure the proof fails
            if !proof.siblings.is_empty() {
                let mut remove_tamper = proof.clone();
                remove_tamper.siblings.pop();
                assert!(
                    remove_tamper
                        .verify_element_inclusion(&mut hasher, leaf, i as u32, &root)
                        .is_err(),
                    "remove fail for size={n} leaf={i}"
                );
            }
        }

        // Test proof for larger than size
        assert!(tree.proof(n as u32).is_err());

        // Return the root so we can ensure we don't silently change.
        root
    }

    /// Roots for all trees with 1..201 leaves.
    ///
    /// We use these pre-generated roots to ensure that we don't silently change
    /// the tree hashing algorithm.
    const ROOTS: [&str; 200] = [
        "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
        "50ae5b142a0f31db537ba060ba07e46fafe1ec960ebec7b6f08f03dafe774f52",
        "04c85c918f4818bf72f35b6927cc548d149dc02a4c711b99da8e48cf79505d55",
        "2a44e8d9bc4ca4019e4755d09092662b4f36114d26ad4c42ecf74f98c763d983",
        "b08e27c42c2a4c7dfb443b7c213da0786262f1e141098870fb31efddb07fe03d",
        "016a500919ad32b7051080df5c4a1d6fa5868d9b7fb6041a1c7b7cd02d3b1895",
        "b2724f72d9d4bd21388f7b52368df08669d74230412664072ae22380affa19fc",
        "6301eac41ebacd8cee5e18fe2f730344d15ac098c741470cbc753a886a761cd8",
        "f1ccf355b396a3a9744e907535cd0003117a792b91f2b438f248df2eb0debaf0",
        "4b6f4827029fb60a3843d7748e2c328cc7ecedd5ece97a175070ed6ba7e83062",
        "6ec4754470486bae02f93c359441981d6bdbdae1778188e3b16c89655189e505",
        "1f7a3e63f8b1987274d49ee77ae2c40cd0d9ca133f7df2fa84c5ca4aaff97636",
        "aa1a2b54c8956de7de3c7c2b8c5404dd8fb624129f3e6f12a134a5dd5069dbd3",
        "19020762586c29181dfc4f23af56d828c57205548ba7c164326eef42d95c2c19",
        "fb7d5b162266cb1faf342f9d72fb5338123ccc37397bfc41a63b46d5b2338633",
        "44d4230ff8b628fadbaf94a73aca30b96c841d6bdd1d6218111462645d81cdb8",
        "81cf55581c8605d2f2b9d9878dd4e57fd0eccb057d4925dfda2f24795f28ed7f",
        "8f5da4093e243d0a1772ce4ab1b5e8a01971e0fed3eafc62ea65381484305150",
        "5649b1d41d913bb8dc3346e53d48fb870079989b7d7edda6a176d7425fa841f4",
        "32206e218ba3b2d6c70908df9e190246d6b1ec7d770c04ec058f43516dca9173",
        "c010a8b1c8f1916f2c7adc2417eebd3a1e17439fd89fc2729370d0c43974aa6b",
        "7f47390b772e1e2afafb7faef428affc68a68731fe704c88dcc05e35110b49b9",
        "4faa6ab37727b59e53eae23562247d8d495d93b23cc1121c85e7003adbba9f22",
        "d217106995cde953560605ce2fc69d192115c972f5d692fafa07142852b844f8",
        "a9c478e27064a383189b509e4f1207c65e311cf4c775e89f53fa5ec7ac528110",
        "366f0eea43dda0d6d67f940b465cfbffca3cbf1a0c7e01482be4a976afb456bc",
        "b7405c564d531149bcb174deefa4d008844fc650b8d5477df0c70a37e672f49f",
        "d9a71aac3cdad138c7191e080b83c2a218ed414d602c48c20ef324c97d07b989",
        "b689b4883a70640652640927ef8bd660aabcc414482cd5b437c78240bd70197c",
        "80cd0ef0461edec141aa7d84e77e8867363d3cacd7fe9480082642fd28d84504",
        "c350ea4d0acb3b79e16dbbcaeadd176067d9973423c0f868eed6e327cc53328b",
        "ca83cccc228011ff65e934d905134b62b14ae0b2a56c09983644f2d8e366108b",
        "4049658c4312d7d7e7c9c3e6151c7331578083aad669c5cb8a58a7d590c1c92d",
        "89406e9215478cfa879a415dcb9341cfb007d9aa81f3b5f123f7e72e7001d9c3",
        "e47dd01f32930c449e79155cd2bf0069bbb031fb67000d77e01048dd523bebbc",
        "c3fcfdaa69ae852431947f759dbc91908c41d5abbfb5e4a472d55dd58a4c52c8",
        "89070a690e5d39f0ed0c9ef24e79cbaa665902d6a0f602324ef6652a09cb1cb3",
        "364b5a5258081acb46f8338de77ec04f53ceac28e0c523196e6bc24502306b66",
        "0f664ecd7b42e1e74051f1a743318257b59edbcb4525e4035fb7142434049dcd",
        "bf06c578bcf81b142f07ee04351829a4826600994f512becad9b76b65fb6fbdb",
        "4bd0cb131234977565d185aad718a55817112ae12442b758b7482ab913720d98",
        "d02005829cf1b57ab707bdbe72bda03d8e8bb0e891b5066f9afbb0953cd9d775",
        "896520d85e051e1d1d5a38685a9809ee9e9ae9a5ff4403ce2957bc09ed8e4f9b",
        "4d9ce3d4f02fd71e4a0b8ce37eed424c691d65e657e7614eb00acbb04efa07dd",
        "8a0498c8f7be98fa04268837ba5e053cd4975f927f172884f4c8febb58675074",
        "26efca3ad4d7519511c753722ed039856bf4dcb957afec4d32e7dd9d1a740bd4",
        "ccfca5b4b9d085de36779a89159361733790ec91807b5d887812a7d16237b3bd",
        "824e2f8b5305f7bf88035b005aacceb879ff552ac9b98ebceb305a6fdba91c4d",
        "a8122f51c2993125d2a22fc93e3c5886fd000153e617608b510cc060756279d1",
        "88ad7c4ad8ff3f3adf85642dd9c82917395d29f17a848a93fe0de9e0bdcd11f5",
        "da37876fb8115aa456bae1e022e50cb4cdbc9473b538f45dc94ad859ce67ed31",
        "bb0fa02219f8e0760df524a482d1fd1c717731e1fbff40592df62b985befa660",
        "afa494fbd346939b7ff617fdcf53375aad0628f99dd185aece3b4156caf8c84c",
        "32cfead3b72e2f1cc27024c385385d92eae5830e21304fd4be1175cea25f6a13",
        "b6070a4b87a2445c9fae1e92bb197ff36d551d26c4aa7be0e36ca393d0ea0c54",
        "b5ebc5d5e5a900bc8c0388329e5e484b1c66abc0c9d899b45054974f26b5a560",
        "79eb0e82aec98fbfc1d4e972ce2d02a06e205f539fab1eaa8b1c669e35e06efd",
        "4af858194fe4d5316807642ceddf13a7a16658481d0d2d2fa8833bcb924c2627",
        "e121434741250aba23ae8499bc0597ea9d5ac29a472e00ba5b5331c135201863",
        "b497c32923876bd4a0c033e94bd91a3afba8b7cd91e5d7860be64761131e8388",
        "d17250fc0066be1d95ee3fc35d53e835c8bae19758b018c7d4286bb15a5be0c6",
        "2e0918ac079fd3f34cd804ac5d1e69c039d91ccd6009fa0b6ad3fc895b4a6685",
        "1fa374f6594b3081878add60ff41b62fd60a5642a2a303b3c3d1a964d9167158",
        "784d372d0b5eff53095f65831721a1e3a0f4edaebf102a5bcc0314fb20b37802",
        "afd2d574caad18cf00c7eb4c11752bac19114ec38be166d698e1e99705d725b5",
        "dbef1c3a52937b9629d161f3416f517c6e1992ba8bb6a7854b3b7f1b7157c7fe",
        "5c89e624262314e9308498a79170da3d336d97330f44c7225c172474ca333c10",
        "bb67b550f9fbf6b8246055d7dfcb0d27d8374fb9fe568a739df512c20f9d402f",
        "713515e07d1e6e30e949744cfccf42d13d622dc82884fde81b5b43f9648c5652",
        "0c2c12be4308947ede78fcb8420e70940629f1bf9874f87799eb666f1fe4ed1f",
        "b3872f89ee2e39ac75c30deaee9c817c3a864f3cde14913efc4749f945966ecc",
        "171f0b82390e505818a1a99d1a2f7a360bdb5d702c9e8e4614462b6eaaf16034",
        "ee210fe026bf6169370b5d156ec12b47ad3624a9273ee2dbe076d17186fb8292",
        "fd60c7a34aab71d0296ef284dbd2dd0bce2e39599912c79097b036fff37b252c",
        "38f6d8cb9a7e14b98ddc163b1e9ba6d45f81dbc299afc4bbdb29f433a2e7542c",
        "a260611be98c3486fd62f6877ee9402603d9acf604300f68629a579d02af1158",
        "351260cb9b5ad64e65cc92d2ee3578df44f5cf5ef91c40716b56b06267085fb4",
        "9627e9d8257b5c4bd1ad1af88ec37c73f21eafa13134c3ade7fed3cc7fa878ac",
        "58dc543329cbb4a6a4fad15923842c41a4c1f1294f7163991a04652cbaf553da",
        "9df306d1ca936b0a27e59600e16a1c1e1e90162c9aa3485c2b2cd4390bd5e826",
        "baf1e33f14bb31e221998710e11ccad566f6e50447cfb35a249b96e0c30a03b5",
        "a5efae46eb3e2e2c31f51ff7206f04ba115cc9eefbd287671654d00ddeef9c6f",
        "626089e5f98b46fc507c881eaa77bd96beb4ac75bdca4d44d7a0027a5498944b",
        "596ed83e82c3563fb4e344cacfb9a919df22cba298637289d3bf383e0612e783",
        "686af2027350dbe539289d591690484620726af332792168386c227b17d2d54d",
        "7291bae290aaffce1c2004f40686b88bc6d9b1318fa953a6e229ebc10152fe46",
        "ec54c96782da180e5cd03960c2bcdc8881adf7501f4a0cf597f8eda46b4f5aea",
        "fc352e516fa516a5df36224c8dc414ec64e63f4b230a553208610f7075e26e7e",
        "9247035b5ebf0bb07d1269cfaa06384381d68118d82831f2b2b535d14eff791c",
        "1ad78bb1ac4d33c2292e78f29d21ca6215c1dd04f808734d98fbbedde50e6c14",
        "3a47a1daad7902b622ce1a2105698ef1311859e75046b60864758e738a6794c6",
        "ad4cb27871623418cc4fb7be3ef7d23bc24c4e160840c16d14647bff43f75cc8",
        "2fb9df0a87bfb0da34d1a8d1827d17e45f9674470d3d83c079666cd24ee11750",
        "16254e08376f5004cda40f0848ea4b5771b02196b6d8bc8a2f236fd0aaf7990b",
        "c586e1fc32d6e38e202e2a2ee8934278966bbc188b66477e6bbceb178d112b3c",
        "bc7290e2b709c1202440c47cf9cb14c8a2662167645ed7870b832948da1ba2e0",
        "b236f9a4a7f526ae7d8625a5926f2054562dfcb08466d3c753db58bef12e59e5",
        "8b99bacd2f789614dd1f196649d9492a8e1b5d6f05de6559f82aa9213ff07780",
        "77425e98f8fdcf06c51d25c325fd24569597e315664e7a66eacd46271c611e0c",
        "aac7975944d795430f5aa0d64fdc2ea548823ffbbde0ab2c332078e4e2cf7a8a",
        "624aa042e23ae55d036d5dbfb16b0f920f19c83799589440a3ffcfca4ae507a3",
        "ac7e3c7e94217329d882de2b1278f2019ad368f0e076f6e0185207348c2f86e3",
        "f9675245f2819ef028840c3598690b1bd409eb95075795e824cf78cd8e0d90cd",
        "a9f5dd4b0ab59f9922002b33c770ae976c3bd9c41b1b6ea5b07984b160858eb4",
        "421714b0a1e2e2bae35e98d49c516c0debeabfe99ae7858a4cac850bb221e015",
        "2df194a437908712b43f069a31b37dcdcc55c11e1af557e5524b4bb01c00a133",
        "c0ab5cf7229bf9433bd9d12b7d5770e6742d916a37cd7e96e1025e88b29e4a86",
        "ba4eb70573d0e013374651b975539902798a552bea9d4b390d23337546e96e06",
        "f7676b5789cb79deb7a7570fafc44b9ca1f083eb24b10d9a2b4a7b92549da070",
        "1d3de41dba82647e3624ef9fb1a48e9bf62fcea08dc7a4382e8463afb4d2e71c",
        "53ee1e1a3a037ad579005f27264df226993730123fbf7520bc57bee1db55eadd",
        "07d156bcd29fc5da32496dcb1cbeec15f7132e7df7e48a804cfe20cd6879cfd0",
        "433fa5d91c9a46f869af09859215a4db9b5377503cc0c100ebf59ecc9a391c37",
        "71948a9eabb4c9967009cca9804a2eb01b4fbb97a6753b8cd36d1b5b4bcd24e1",
        "cc5bb0a38a760438a9e3bc3b01451ed64d578d2a4bd842f2fc7fd19380d038bf",
        "744e6f0fd5364f76c7794ffd2c801a206eb34bb96c0c94d87ead9a0e677427aa",
        "098004e07d569449fa070719528219f5939ffcf3e801f46f297d5599b831b850",
        "73f252c8018660051b664f2c71c0104ddf8b5d4d4b8cd199876108099650a3d4",
        "d13fbc95ce0079902c5cf8dfadf5b623f26f8205d344a13eb0f1838e6055604d",
        "8b53750c7d4a42fe3841a5e6f444eaf8664cb629d329b369364da77375a7e44f",
        "0657b7dfb43f5ba5fd27cbb17d87c24c8cb993bfa1accf6b2949559e346af0ee",
        "638ade72e521bc28b40c781d4ab725d414883909e97add136328f42a9feb470e",
        "ef9ecb878e968e53edef234d0b1122309070aa6bc76c45b0aea2c3c4c8e3bd21",
        "92b53ed61b8a64581b803c994d6f574a14e7071c28800619849a847a693b60c2",
        "4a3c39f149154abd2c7a328d9e8ca3eda1c19971f856a425a83b6848907daa5c",
        "cd22c54831bf379873bd82dcc1960c042852b3fb52519e77c2ac8714c81856d1",
        "86f24f8ba88c47dd8f12682044b92b97c97c5fc9b852ad9e1f24548c70c77e8f",
        "617001a9c032d8a0f02acf03dfd027ad5810a4e9b5a86750a71833761846de73",
        "3def0ff4be838296b8adee4b4eec66639d1b9420f244b8685a3fbceb7395741d",
        "202f62232c68397cbfd358662a577f023d67302eef734c7bce6d7d1689a13574",
        "4cc2b4e475604c604b85b487c0b143b6b9c3fd8abcbfa242bb7ec966619203ab",
        "f7a65edc3a04cb80cef5e2bceb4734d83e7c71e6f43c7728cd579de9fb2dc530",
        "7157907b49d5e80d5ee694d34502a9bd6f6c1bc7bec652fbf592d4406f58b37f",
        "17024782e760d081ac02d0a6cfe7310e612c80e8d5bdca5505611b4b0dd9aa73",
        "4e532668bf1581daf0a3126dfa175ea8da883672147a2d02a5aabfab1ccc6925",
        "569f42e8c25892c2e338a4222c75690e0bd21f4ca8f16b1f422acc9388d15502",
        "1b7005fe1eefefad5cfedbe4112606674c01c318ceddaf00cecb1e5b4d5dd812",
        "067b870d1c4235307ed28c5dde575005a6984e215b5826d709c0792aeb5a4c38",
        "17a3ac90842906f6026b8319b2f315fc542ece19ce5d2dda320f34c7856ffc69",
        "0cc44d88ad53d1544b2879dfa2c48312c3a90bfd322d1cb730e18ac3596d1590",
        "6a0c459f1352f556be903e3567e23774c01b3dcf21b9cf1513da5e489277ba69",
        "2fa5058014c3561a2dbe318dca0da686c8da804ab4606536832f640a6d00c39a",
        "6f4fbdbdd906a9911182938cfb9e7d50a007d5084dc8def8be8c9ac089534cba",
        "057bdc4252865c81cb878b5414ba22399b976792ab82f1b7044f54fe89a8dbc8",
        "fa64db9f47421b1fc8f1e74c2307ec635fc1b1611469e574fe89671e786fbacd",
        "dc773f5d6f9db1cae85d59b0d72c2d677045de6c28745dbbf58b6bf1c3476b29",
        "465075e1b7e0b4df55241fabd41451cbcf4f03fc6291300b40d9c84dd62218a3",
        "03e7b67b6df966405519fea36e6aabdb979aa07f15e8b6af1887d441d3d99212",
        "1e64c8358066edcc5e77de536025705eba1c0c292b6feb098ecc76a330229ba1",
        "35f89f2155e041de8a5fafdd834e228d286b5b5e64c4a66677f3270d7406b089",
        "7e77d52bdb94d2777206c5b8610a8a2a7dc283f06332ed4fc5a7c371b9df84e2",
        "7aab6f5da0cc34f513996d164772a3f77636056c12e6f76833e9fae9d43dc4ba",
        "873271b129688e944d5eae7f1e19b57605d5cff5e7379601176061fb5644d10d",
        "de9f96e1f0f14bd84438b5e088a04ed8887648ad7e7bd64735b79afdd385020d",
        "b9a156ab0f9e1b3550a7b7d9f9082ece31af3ede09a0210813b5a5c82bb7209c",
        "a9d817d6f80f4f95060ca44b6f1836abef81b03e3d5466aaf1654dd69e872dfc",
        "65c495985cdca5ebb475ba3c7ff0aca4ee2dae1fb0dfd579d4945a965ad22fb3",
        "427ad1f38a99fc5b5eed815ee651e5cb2975c82c29cfcddfa1063086c1d0012a",
        "05d04d7521b1c8dcda8f5ac635e48e56fc0798bff0508d137483bcf4db77b977",
        "1a0a347e49c2de9301a1638c96c4ec19e5bedec1c076e3e777722a49d05e1069",
        "fedb28cabfd8301797a4af20ebe0d4cf72fa8f117b18ab5a1c76b2f5426f55d3",
        "38a23bac4ce24c6b09b3468936d74ff426ec4c4a0b6287b05393ea18a46f3051",
        "3a125e7e5879c3b1acf9b9b4c7fbc9c241ce4f89c1fd0e69500570d739488ae4",
        "12f2287adbf0881f25ec70ef45e654cb1e711ffb2be0796ef75a723a61c0103a",
        "3c3c7e7f216adef9bf2f2506e6a0119b6667d7fd2895ce5962fa2222651c9bb0",
        "bea9e7eebfa03cce6d14f552c48eea71369aaf27b6c690772d5161235f207336",
        "d735072f5a5a2123d860f9e18434188acc102d88648a70c63e72da6baeca084e",
        "a62bdff1cc81727d30e9ea4860da15f9b54f3f0738164221d4d1e6fc23e8e6d7",
        "1dbaba01bb25cfa06ed8e0001343d5f442cde324dbb64b2d852b90a060d02c49",
        "c0f93aafbead58eb1ef917c0e4f050db21c5608df1328684a8a38c74b12e7bdd",
        "953885e1e754645ef602909834b6c4377112abc299fc0b9e2e612e096ee8e9fc",
        "6c100a673f4c39efd99093005550fce6e545900bcf3d44b36428c311c5cd2c41",
        "5cbf7391c4036058dd16bd6c369a4ff12852b0d59de6608af4e70764430098ec",
        "6e9dd55611e26f118b43b7ceea876be10f94be540d8fcf00a892ffc63b8b7b07",
        "11aafdc65480aa713bc222893bb84fd6be0f92c0d4757e8d876e8e4e9831cdef",
        "c8d67d266f814ee3524df878f4c3f8cf32bf9c57eaf7c5b7c608b398a7bab97b",
        "a826218ff82e67a9455084cea00ff6cbad4c3bc7edee549e31253d0d9417b3d4",
        "1be15ca3c5dabcf35a3acb61c6a94a8faf351d281413219db1c5031a26d08fac",
        "ffe8871395563699fb76038a4a9934a2cb12a0a70da6108906ed6524c9cf08f5",
        "e7fafa815d564c5194366ef8ae1e2fd7231419cfa0517386ee237792cc87db16",
        "4e060a11b691438bdf039de27e80b031551919c66fe4531607102b73022c401b",
        "e220449764ad675f5045c7a2ed04907aadf046b47869768e2fb6152505cfd1e6",
        "e55aabfe09d931d5902c6a94eaacf80ff6d24d1da7a1ceb8075eb3b75ad8e58c",
        "666eec9c0eb2e614540f99e0efe9adfeb032958c7eec59a90cfdb2ac6b25016e",
        "bbc9e3cc28161bdec33d3310f1a8e3847bccc6d5b14d0fe31422806e85632d66",
        "56cbb28d82023cec121e30bd7d5b27eb02684966658d33bb2f99165761628990",
        "17515485fd89d817410d7683f6a72f63751daedf219377dc11b5a1fb7ec3443c",
        "d165b752514e32c5f26eb6dbec3e3b773accb347bf32a4f1dc54df266f6d9a7f",
        "6b3235bb52b52b007655334b390d7b1dc9132adfd8e5ea08ff1b8e9eb29bf7a4",
        "718f4495678a050edde9fe49eb5fbcb514dd6918409cf50a9692dd694b70e036",
        "403c61e3166cb22641b14aa6e75c6f72e66ac5af1fd13925111e0a7eda8547e5",
        "82b15231d83c4222e999b04b163742bad69ac1f6e78663b0d6e3b7a3fbff569f",
        "987fa65e2944d12d635ea0c6b52511f41559d89a6471147ea1e0f2b338294b1c",
        "89ec098b9b9232aec3f9eb22f30bd7deffdb58cf2ac9b6396583e3754dedb8e2",
        "bcf9467d01db1036e421677df4eafb3ca4dab5ddd8a69a5f3843cbc88953b8f2",
        "9f1cb3ac49000ddda8dc1d3da2dcadcbd15bf17b95d79b6f4d549ee19b9cd7b1",
        "84758043514cef64af44fd5d013dcd294e5f283722552aa66d23aa3d4d1fc819",
        "d518391bf106cb3a76b2ef980def833d82d9859be195b756f5a1f72dd6ae68a9",
        "16f16fb875fe936f7966812add16f1800cf5b1392da4ca8d07a63030500dabe3",
        "e00c059c990cdb168d997f09b9432f86bda043885fb80d3c35ee3414de5a8510",
    ];

    #[test]
    fn test_merkle_trees() {
        for (n, previous) in ROOTS.into_iter().enumerate() {
            let root = test_merkle_tree(n);
            assert_eq!(hex(&root), previous);
        }
    }

    #[test]
    #[ignore]
    fn generate_bmt_roots() {
        println!("const ROOTS: [&str; 200] = [");
        for n in 0..200 {
            let root = test_merkle_tree(n);
            println!("    \"{}\",", hex(&root));
        }
        println!("];");
    }

    #[test]
    fn test_tampered_proof_no_siblings() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
        let element = &digests[0];

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Build proof
        let mut proof = tree.proof(0).unwrap();

        // Tamper with proof
        proof.siblings = Vec::new();

        // Fail verification with an empty proof.
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, element, 0, &root)
            .is_err());
    }

    #[test]
    fn test_tampered_proof_extra_sibling() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();
        let element = &digests[0];

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Build proof
        let mut proof = tree.proof(0).unwrap();

        // Tamper with proof
        proof.siblings.push(*element);

        // Fail verification with extra sibling
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, element, 0, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_element() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 2.
        let proof = tree.proof(2).unwrap();

        // Use a wrong element (e.g. hash of a different transaction).
        let mut hasher = Sha256::default();
        let wrong_leaf = Sha256::hash(b"wrong_tx");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &wrong_leaf, 2, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_index() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();

        // Use an incorrect index (e.g. 2 instead of 1).
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[1], 2, &root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_wrong_root() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 0.
        let proof = tree.proof(0).unwrap();

        // Use a wrong root (hash of a different input).
        let mut hasher = Sha256::default();
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[0], 0, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_invalid_proof_serialization_truncated() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();
        let mut serialized = proof.encode();

        // Truncate one byte.
        serialized.truncate(serialized.len() - 1);
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &1).is_err());
    }

    #[test]
    fn test_invalid_proof_serialization_extra() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate a valid proof for leaf at index 1.
        let proof = tree.proof(1).unwrap();
        let mut serialized = proof.encode_mut();

        // Append an extra byte.
        serialized.extend_from_slice(&[0u8]);
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &1).is_err());
    }

    #[test]
    fn test_invalid_proof_modified_hash() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3", b"tx4"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Generate a valid proof for leaf at index 2.
        let mut proof = tree.proof(2).unwrap();

        // Modify the first hash in the proof.
        let mut hasher = Sha256::default();
        proof.siblings[0] = Sha256::hash(b"modified");
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 2, &root)
            .is_err());
    }

    #[test]
    fn test_odd_tree_duplicate_index_proof() {
        // Create transactions and digests
        let txs = [b"tx1", b"tx2", b"tx3"];
        let digests: Vec<Digest> = txs.iter().map(|tx| Sha256::hash(*tx)).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(txs.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // The tree was built with 3 leaves; index 2 is the last valid index.
        let proof = tree.proof(2).unwrap();

        // Verification should succeed for the proper index 2.
        let mut hasher = Sha256::default();
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 2, &root)
            .is_ok());

        // Should not be able to generate a proof for an out-of-range index (e.g. 3).
        assert!(tree.proof(3).is_err());

        // Attempting to verify using an out-of-range index (e.g. 3, which would correspond
        // to a duplicate leaf that doesn't actually exist) should fail.
        assert!(proof
            .verify_element_inclusion(&mut hasher, &digests[2], 3, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_basic() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test range proof for elements 2-5
        let range_proof = tree.range_proof(2, 5).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..6];

        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_ok());

        // Serialize and deserialize
        let mut serialized = range_proof.encode();
        let deserialized = RangeProof::<Digest>::decode(&mut serialized).unwrap();
        assert!(deserialized
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_ok());
    }

    #[test]
    fn test_range_proof_single_element() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test single element range proof
        for (i, digest) in digests.iter().enumerate() {
            let range_proof = tree.range_proof(i as u32, i as u32).unwrap();
            let mut hasher = Sha256::default();

            let result = range_proof.verify(&mut hasher, i as u32, &[*digest], &root);
            assert!(result.is_ok());
        }
    }

    #[test]
    fn test_range_proof_full_tree() {
        // Create test data
        let digests: Vec<Digest> = (0..7u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test full tree range proof
        let range_proof = tree.range_proof(0, (digests.len() - 1) as u32).unwrap();
        let mut hasher = Sha256::default();
        assert!(range_proof.verify(&mut hasher, 0, &digests, &root).is_ok());
    }

    #[test]
    fn test_range_proof_edge_cases() {
        // Create test data
        let digests: Vec<Digest> = (0..15u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test first half
        let range_proof = tree.range_proof(0, 7).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 0, &digests[0..8], &root)
            .is_ok());

        // Test second half
        let range_proof = tree.range_proof(8, 14).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 8, &digests[8..15], &root)
            .is_ok());

        // Test last elements
        let range_proof = tree.range_proof(13, 14).unwrap();
        assert!(range_proof
            .verify(&mut hasher, 13, &digests[13..15], &root)
            .is_ok());
    }

    #[test]
    fn test_range_proof_invalid_range() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test invalid ranges
        assert!(tree.range_proof(8, 8).is_err()); // Start out of bounds
        assert!(tree.range_proof(0, 8).is_err()); // End out of bounds
        assert!(tree.range_proof(5, 8).is_err()); // End out of bounds
        assert!(tree.range_proof(2, 1).is_err()); // Start > end
    }

    #[test]
    fn test_range_proof_tampering() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..5];

        // Test with wrong leaves
        let wrong_leaves = vec![
            Sha256::hash(b"wrong1"),
            Sha256::hash(b"wrong2"),
            Sha256::hash(b"wrong3"),
        ];
        assert!(range_proof
            .verify(&mut hasher, 2, &wrong_leaves, &root)
            .is_err());

        // Test with wrong number of leaves
        assert!(range_proof
            .verify(&mut hasher, 2, &digests[2..4], &root)
            .is_err());

        // Test with tampered proof
        let mut tampered_proof = range_proof.clone();
        assert!(!tampered_proof.siblings.is_empty());
        // Tamper with the first level's left sibling if it exists
        if let Some(ref mut left) = tampered_proof.siblings[0].left {
            *left = Sha256::hash(b"tampered");
        } else if let Some(ref mut right) = tampered_proof.siblings[0].right {
            *right = Sha256::hash(b"tampered");
        }
        assert!(tampered_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());

        // Test with wrong root
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_range_proof_various_sizes() {
        // Test range proofs for trees of various sizes
        for tree_size in [1, 2, 3, 4, 5, 7, 8, 15, 16, 31, 32, 63, 64] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_le_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test various range sizes
            for range_size in 1..=tree_size.min(8) {
                for start in 0..=(tree_size - range_size) {
                    let range_proof = tree
                        .range_proof(start as u32, (start + range_size - 1) as u32)
                        .unwrap();
                    let end = start + range_size;
                    assert!(
                        range_proof
                            .verify(&mut hasher, start as u32, &digests[start..end], &root)
                            .is_ok(),
                        "Failed for tree_size={tree_size}, start={start}, range_size={range_size}"
                    );
                }
            }
        }
    }

    #[test]
    fn test_range_proof_malicious_wrong_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for position 2 to 4
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..5];

        // Try to verify with wrong position
        assert!(range_proof
            .verify(&mut hasher, 3, range_leaves, &root)
            .is_err());
        assert!(range_proof
            .verify(&mut hasher, 1, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_reordered_leaves() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for position 2 to 4
        let range_proof = tree.range_proof(2, 4).unwrap();
        let mut hasher = Sha256::default();

        // Try to verify with reordered leaves
        let reordered_leaves = vec![digests[3], digests[2], digests[4]];
        assert!(range_proof
            .verify(&mut hasher, 2, &reordered_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_extra_siblings() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let mut range_proof = tree.range_proof(2, 3).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..4];

        // Tamper by setting both siblings when there should only be one or two
        assert!(!range_proof.siblings.is_empty());
        // Force an invalid state by modifying the siblings
        if range_proof.siblings[0].left.is_none() {
            range_proof.siblings[0].left = Some(Sha256::hash(b"extra"));
        } else if range_proof.siblings[0].right.is_none() {
            range_proof.siblings[0].right = Some(Sha256::hash(b"extra"));
        }
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_malicious_missing_siblings() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof for a single element (which needs siblings)
        let mut range_proof = tree.range_proof(2, 2).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..3];

        // The proof should have siblings at the first level
        assert!(!range_proof.siblings.is_empty());
        assert!(range_proof.siblings[0].left.is_some() || range_proof.siblings[0].right.is_some());

        // Remove a sibling from a level
        range_proof.siblings[0].left = None;
        range_proof.siblings[0].right = None;
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_integer_overflow_protection() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test overflow in range_proof generation
        assert!(tree.range_proof(u32::MAX, u32::MAX).is_err());
        assert!(tree.range_proof(u32::MAX - 1, u32::MAX).is_err());
        assert!(tree.range_proof(7, u32::MAX).is_err());
    }

    #[test]
    fn test_range_proof_malicious_wrong_tree_structure() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Get valid range proof
        let mut range_proof = tree.range_proof(2, 3).unwrap();
        let mut hasher = Sha256::default();
        let range_leaves = &digests[2..4];

        // Add extra level (simulating proof from different tree structure)
        range_proof.siblings.push(Bounds {
            left: Some(Sha256::hash(b"fake_level")),
            right: None,
        });
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());

        // Remove a level
        let mut range_proof = tree.range_proof(2, 2).unwrap();
        assert!(!range_proof.siblings.is_empty());
        range_proof.siblings.pop();
        assert!(range_proof
            .verify(&mut hasher, 2, range_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_range_proof_boundary_conditions() {
        // Test various power-of-2 boundary conditions
        for tree_size in [1, 2, 4, 8, 16, 32] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_le_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test edge cases
            // First element only
            let proof = tree.range_proof(0, 0).unwrap();
            assert!(proof.verify(&mut hasher, 0, &digests[0..1], &root).is_ok());

            // Last element only
            let last_idx = tree_size - 1;
            let proof = tree.range_proof(last_idx as u32, last_idx as u32).unwrap();
            assert!(proof
                .verify(
                    &mut hasher,
                    last_idx as u32,
                    &digests[last_idx..tree_size],
                    &root
                )
                .is_ok());

            // Full tree
            let proof = tree.range_proof(0, (tree_size - 1) as u32).unwrap();
            assert!(proof.verify(&mut hasher, 0, &digests, &root).is_ok());
        }
    }

    #[test]
    fn test_empty_tree_proof() {
        // Build an empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();

        // Empty tree should fail for any position since there are no elements
        assert!(tree.proof(0).is_err());
        assert!(tree.proof(1).is_err());
        assert!(tree.proof(100).is_err());
    }

    #[test]
    fn test_empty_tree_range_proof() {
        // Build an empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();
        let root = tree.root();

        // Empty tree should return default range proof only for (0, 0)
        let range_proof = tree.range_proof(0, 0).unwrap();
        assert!(range_proof.siblings.is_empty());
        assert_eq!(range_proof, RangeProof::default());

        // All other combinations should fail
        let invalid_ranges = vec![
            (0, 1),
            (0, 10),
            (1, 1),
            (1, 2),
            (5, 5),
            (10, 10),
            (0, u32::MAX),
            (u32::MAX, u32::MAX),
        ];
        for (start, end) in invalid_ranges {
            assert!(tree.range_proof(start, end).is_err());
        }

        // Verify empty range proof against empty tree root
        let mut hasher = Sha256::default();
        let empty_leaves: &[Digest] = &[];
        assert!(range_proof
            .verify(&mut hasher, 0, empty_leaves, &root)
            .is_ok());

        // Should fail with non-empty leaves
        let non_empty_leaves = vec![Sha256::hash(b"leaf")];
        assert!(range_proof
            .verify(&mut hasher, 0, &non_empty_leaves, &root)
            .is_err());

        // Should fail with wrong root
        let wrong_root = Sha256::hash(b"wrong");
        assert!(range_proof
            .verify(&mut hasher, 0, empty_leaves, &wrong_root)
            .is_err());

        // Should fail with wrong position
        assert!(range_proof
            .verify(&mut hasher, 1, empty_leaves, &root)
            .is_err());
    }

    #[test]
    fn test_empty_range_proof_serialization() {
        let range_proof = RangeProof::<Digest>::default();
        let mut serialized = range_proof.encode();
        let deserialized = RangeProof::<Digest>::decode(&mut serialized).unwrap();
        assert_eq!(range_proof, deserialized);
    }

    #[test]
    fn test_empty_tree_root_consistency() {
        // Create multiple empty trees and verify they have the same root
        let mut roots = Vec::new();
        for _ in 0..5 {
            let builder = Builder::<Sha256>::new(0);
            let tree = builder.build();
            roots.push(tree.root());
        }

        // All empty trees should have the same root
        for i in 1..roots.len() {
            assert_eq!(roots[0], roots[i]);
        }

        // The root should be the hash of empty data
        let mut hasher = Sha256::default();
        let expected_root = hasher.finalize();
        assert_eq!(roots[0], expected_root);
    }

    #[rstest]
    #[case::need_left_sibling(1, 2)] // Range starting at odd index (needs left sibling)
    #[case::need_right_sibling(4, 4)] // Range starting at even index ending at odd (needs right sibling)
    #[case::boundaries_both_single_children(4, 4)] // Range with both boundaries needing siblings
    #[case::full_tree(0, 16)] // Full tree (no siblings needed at leaf level)
    fn test_range_proof_bounds_usage(#[case] start: u32, #[case] count: u32) {
        // This test ensures that all bounds in a range proof are actually used during verification
        // and that we don't have unnecessary siblings
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        let range_proof = tree.range_proof(start, start + count - 1).unwrap();
        let end = start as usize + count as usize;

        // Verify the proof works
        assert!(range_proof
            .verify(&mut hasher, start, &digests[start as usize..end], &root)
            .is_ok());

        // For each level with siblings, try removing them and verify the proof fails
        for level_idx in 0..range_proof.siblings.len() {
            let bounds = &range_proof.siblings[level_idx];

            // If there's a left sibling, removing it should make the proof fail
            if bounds.left.is_some() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].left = None;
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's a right sibling, removing it should make the proof fail
            if bounds.right.is_some() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].right = None;
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's no left sibling, adding one should make the proof fail
            if bounds.left.is_none() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].left = Some(Sha256::hash(b"fake_left"));
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }

            // If there's no right sibling, adding one should make the proof fail
            if bounds.right.is_none() {
                let mut tampered_proof = range_proof.clone();
                tampered_proof.siblings[level_idx].right = Some(Sha256::hash(b"fake_right"));
                assert!(tampered_proof
                    .verify(&mut hasher, start, &digests[start as usize..end], &root)
                    .is_err());
            }
        }
    }

    // Test trees with odd sizes that require duplicate nodes
    #[rstest]
    fn test_range_proof_duplicate_node_edge_cases(
        #[values(3, 5, 7, 9, 11, 13, 15)] tree_size: usize,
    ) {
        let digests: Vec<Digest> = (0..tree_size as u32)
            .map(|i| Sha256::hash(&i.to_le_bytes()))
            .collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test range including the last element (which may require duplicate handling)
        let start = tree_size - 2;
        let proof = tree
            .range_proof(start as u32, (tree_size - 1) as u32)
            .unwrap();
        assert!(proof
            .verify(&mut hasher, start as u32, &digests[start..tree_size], &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_basic() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();

        // Test multi-proof for non-contiguous positions [0, 3, 5]
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();
        let mut hasher = Sha256::default();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_single_element() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test single element multi-proof for each position
        for (i, digest) in digests.iter().enumerate() {
            let multi_proof = tree.multi_proof(&[i as u32]).unwrap();
            let elements = [(*digest, i as u32)];
            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_ok(),
                "Failed for position {i}"
            );
        }
    }

    #[test]
    fn test_multi_proof_all_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test multi-proof for all elements
        let positions: Vec<u32> = (0..digests.len() as u32).collect();
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());

        // When proving all elements, we shouldn't need any siblings (all can be computed)
        assert!(multi_proof.siblings.is_empty());
    }

    #[test]
    fn test_multi_proof_adjacent_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test adjacent positions (should deduplicate shared siblings)
        let positions = [2, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_sparse_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test widely separated positions
        let positions = [0, 7, 8, 15];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_empty_tree() {
        // Build empty tree
        let builder = Builder::<Sha256>::new(0);
        let tree = builder.build();

        // Empty tree with empty positions should return NoLeaves error
        // (we can't prove zero elements)
        assert!(matches!(tree.multi_proof(&[]), Err(Error::NoLeaves)));

        // Empty tree with any position should fail with InvalidPosition
        assert!(matches!(
            tree.multi_proof(&[0]),
            Err(Error::InvalidPosition(0))
        ));
    }

    #[test]
    fn test_multi_proof_empty_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Empty positions should return error
        assert!(matches!(tree.multi_proof(&[]), Err(Error::NoLeaves)));
    }

    #[test]
    fn test_multi_proof_duplicate_positions_error() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Duplicate positions should return error
        assert!(matches!(
            tree.multi_proof(&[1, 1]),
            Err(Error::DuplicatePosition(1))
        ));
        assert!(matches!(
            tree.multi_proof(&[0, 2, 2, 5]),
            Err(Error::DuplicatePosition(2))
        ));
    }

    #[test]
    fn test_multi_proof_unsorted_input() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Test with unsorted positions (should work - internal sorting)
        let positions = [5, 0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with unsorted elements (should work - internal sorting)
        let unsorted_elements = [(digests[5], 5), (digests[0], 0), (digests[3], 3)];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &unsorted_elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_various_sizes() {
        // Test multi-proofs for trees of various sizes
        for tree_size in [1, 2, 3, 4, 5, 7, 8, 15, 16, 31, 32] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_le_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test various position combinations
            // First and last
            if tree_size >= 2 {
                let positions = [0, (tree_size - 1) as u32];
                let multi_proof = tree.multi_proof(&positions).unwrap();
                let elements: Vec<(Digest, u32)> = positions
                    .iter()
                    .map(|&p| (digests[p as usize], p))
                    .collect();
                assert!(
                    multi_proof
                        .verify_multi_inclusion(&mut hasher, &elements, &root)
                        .is_ok(),
                    "Failed for tree_size={tree_size}, positions=[0, {}]",
                    tree_size - 1
                );
            }

            // Every other element
            if tree_size >= 4 {
                let positions: Vec<u32> = (0..tree_size as u32).step_by(2).collect();
                let multi_proof = tree.multi_proof(&positions).unwrap();
                let elements: Vec<(Digest, u32)> = positions
                    .iter()
                    .map(|&p| (digests[p as usize], p))
                    .collect();
                assert!(
                    multi_proof
                        .verify_multi_inclusion(&mut hasher, &elements, &root)
                        .is_ok(),
                    "Failed for tree_size={tree_size}, every other element"
                );
            }
        }
    }

    #[test]
    fn test_multi_proof_wrong_elements() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with wrong elements
        let wrong_elements = [
            (Sha256::hash(b"wrong1"), 0),
            (digests[3], 3),
            (digests[5], 5),
        ];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &wrong_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_wrong_positions() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Verify with wrong positions (same elements, different positions)
        let wrong_positions = [
            (digests[0], 1), // wrong position
            (digests[3], 3),
            (digests[5], 5),
        ];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &wrong_positions, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_wrong_root() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Verify with wrong root
        let wrong_root = Sha256::hash(b"wrong_root");
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_tampering() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Tamper with sibling
        assert!(!multi_proof.siblings.is_empty());
        let mut modified = multi_proof.clone();
        modified.siblings[0] = Sha256::hash(b"tampered");
        assert!(modified
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());

        // Add extra sibling
        let mut extra = multi_proof.clone();
        extra.siblings.push(Sha256::hash(b"extra"));
        assert!(extra
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());

        // Remove a sibling
        let mut missing = multi_proof;
        missing.siblings.pop();
        assert!(missing
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_deduplication() {
        // Create test data
        let digests: Vec<Digest> = (0..16u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Get individual proofs
        let individual_siblings: usize = [0u32, 1, 8, 9]
            .iter()
            .map(|&p| tree.proof(p).unwrap().siblings.len())
            .sum();

        // Get multi-proof for same positions
        let multi_proof = tree.multi_proof(&[0, 1, 8, 9]).unwrap();

        // Multi-proof should have fewer siblings due to deduplication
        assert!(
            multi_proof.siblings.len() < individual_siblings,
            "Multi-proof ({}) should have fewer siblings than sum of individual proofs ({})",
            multi_proof.siblings.len(),
            individual_siblings
        );
    }

    #[test]
    fn test_multi_proof_serialization() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and deserialize
        let serialized = multi_proof.encode();
        let deserialized = Proof::<Digest>::decode_cfg(serialized, &positions.len()).unwrap();

        assert_eq!(multi_proof, deserialized);

        // Verify deserialized proof works
        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();
        assert!(deserialized
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_ok());
    }

    #[test]
    fn test_multi_proof_serialization_truncated() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and truncate
        let mut serialized = multi_proof.encode();
        serialized.truncate(serialized.len() - 1);

        // Should fail to deserialize
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &positions.len()).is_err());
    }

    #[test]
    fn test_multi_proof_serialization_extra() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Generate proof
        let positions = [0, 3, 5];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Serialize and add extra byte
        let mut serialized = multi_proof.encode_mut();
        serialized.extend_from_slice(&[0u8]);

        // Should fail to deserialize
        assert!(Proof::<Digest>::decode_cfg(&mut serialized, &positions.len()).is_err());
    }

    #[test]
    fn test_multi_proof_decode_insufficient_data() {
        let mut serialized = Vec::new();
        serialized.extend_from_slice(&8u32.encode()); // leaf_count
        serialized.extend_from_slice(&1usize.encode()); // claims 1 sibling but no data follows

        // Should fail because the buffer claims 1 sibling but doesn't have the data
        let err = Proof::<Digest>::decode_cfg(serialized.as_slice(), &1).unwrap_err();
        assert!(matches!(err, commonware_codec::Error::EndOfBuffer));
    }

    #[test]
    fn test_multi_proof_invalid_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();

        // Test out of bounds position
        assert!(matches!(
            tree.multi_proof(&[0, 8]),
            Err(Error::InvalidPosition(8))
        ));
        assert!(matches!(
            tree.multi_proof(&[100]),
            Err(Error::InvalidPosition(100))
        ));
    }

    #[test]
    fn test_multi_proof_verify_invalid_position() {
        // Create test data
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        // Build tree
        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with out of bounds position
        let invalid_elements = [(digests[0], 0), (digests[3], 100)];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &invalid_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_odd_tree_sizes() {
        // Test odd-sized trees that require node duplication
        for tree_size in [3, 5, 7, 9, 11, 13, 15] {
            let digests: Vec<Digest> = (0..tree_size as u32)
                .map(|i| Sha256::hash(&i.to_le_bytes()))
                .collect();

            // Build tree
            let mut builder = Builder::<Sha256>::new(digests.len());
            for digest in &digests {
                builder.add(digest);
            }
            let tree = builder.build();
            let root = tree.root();
            let mut hasher = Sha256::default();

            // Test with positions including the last element
            let positions = [0, (tree_size - 1) as u32];
            let multi_proof = tree.multi_proof(&positions).unwrap();

            let elements: Vec<(Digest, u32)> = positions
                .iter()
                .map(|&p| (digests[p as usize], p))
                .collect();
            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_ok(),
                "Failed for tree_size={tree_size}"
            );
        }
    }

    #[test]
    fn test_multi_proof_verify_empty_elements() {
        // Create a valid proof and try to verify with empty elements
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with empty elements
        let empty_elements: &[(Digest, u32)] = &[];
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_default_verify() {
        // Default (empty) proof should only verify against empty tree
        let mut hasher = Sha256::default();
        let default_proof = Proof::<Digest>::default();

        // Empty elements against default proof
        let empty_elements: &[(Digest, u32)] = &[];

        // Build empty tree to get the empty root
        let builder = Builder::<Sha256>::new(0);
        let empty_tree = builder.build();
        let empty_root = empty_tree.root();

        assert!(default_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &empty_root)
            .is_ok());

        // Should fail with wrong root
        let wrong_root = Sha256::hash(b"not_empty");
        assert!(default_proof
            .verify_multi_inclusion(&mut hasher, empty_elements, &wrong_root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_single_leaf_tree() {
        // Edge case: tree with exactly one leaf
        let digest = Sha256::hash(b"only_leaf");

        // Build single-leaf tree
        let mut builder = Builder::<Sha256>::new(1);
        builder.add(&digest);
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate multi-proof for the only leaf
        let multi_proof = tree.multi_proof(&[0]).unwrap();

        // Single leaf tree: leaf_count should be 1
        assert_eq!(multi_proof.leaf_count, 1);

        // Single leaf tree: no siblings needed (leaf is the root after position hashing)
        assert!(
            multi_proof.siblings.is_empty(),
            "Single leaf tree should have no siblings"
        );

        // Verify the proof
        let elements = [(digest, 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_ok(),
            "Single leaf multi-proof verification failed"
        );

        // Verify with wrong digest fails
        let wrong_digest = Sha256::hash(b"wrong");
        let wrong_elements = [(wrong_digest, 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &wrong_elements, &root)
                .is_err(),
            "Should fail with wrong digest"
        );

        // Verify with wrong position fails
        let wrong_position_elements = [(digest, 1u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &wrong_position_elements, &root)
                .is_err(),
            "Should fail with invalid position"
        );
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_zero() {
        // Attacker sets leaf_count = 0 but provides siblings
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and tamper with leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        multi_proof.leaf_count = 0;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - leaf_count=0 but we have elements
        assert!(multi_proof
            .verify_multi_inclusion(&mut hasher, &elements, &root)
            .is_err());
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_larger() {
        // Attacker inflates leaf_count to claim proof is for larger tree
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and inflate leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        let original_leaf_count = multi_proof.leaf_count;
        multi_proof.leaf_count = 1000;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - inflated leaf_count changes required siblings
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_err(),
            "Should reject proof with inflated leaf_count ({} -> {})",
            original_leaf_count,
            multi_proof.leaf_count
        );
    }

    #[test]
    fn test_multi_proof_malicious_leaf_count_smaller() {
        // Attacker deflates leaf_count to claim proof is for smaller tree
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof and deflate leaf_count
        let positions = [0, 3];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();
        multi_proof.leaf_count = 4; // Smaller than actual tree

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // Should fail - deflated leaf_count changes tree structure
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &elements, &root)
                .is_err(),
            "Should reject proof with deflated leaf_count"
        );
    }

    #[test]
    fn test_multi_proof_mismatched_element_count() {
        // Provide more or fewer elements than the proof was generated for
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate proof for 2 positions
        let positions = [0, 3];
        let multi_proof = tree.multi_proof(&positions).unwrap();

        // Try to verify with only 1 element (too few)
        let too_few = [(digests[0], 0u32)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &too_few, &root)
                .is_err(),
            "Should reject when fewer elements provided than proof was generated for"
        );

        // Try to verify with 3 elements (too many)
        let too_many = [(digests[0], 0u32), (digests[3], 3), (digests[5], 5)];
        assert!(
            multi_proof
                .verify_multi_inclusion(&mut hasher, &too_many, &root)
                .is_err(),
            "Should reject when more elements provided than proof was generated for"
        );
    }

    #[test]
    fn test_multi_proof_swapped_siblings() {
        // Swap the order of siblings in the proof
        let digests: Vec<Digest> = (0..8u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof with multiple siblings
        let positions = [0, 5];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();

        // Ensure we have at least 2 siblings to swap
        if multi_proof.siblings.len() >= 2 {
            // Swap first two siblings
            multi_proof.siblings.swap(0, 1);

            let elements: Vec<(Digest, u32)> = positions
                .iter()
                .map(|&p| (digests[p as usize], p))
                .collect();

            assert!(
                multi_proof
                    .verify_multi_inclusion(&mut hasher, &elements, &root)
                    .is_err(),
                "Should reject proof with swapped siblings"
            );
        }
    }

    #[test]
    fn test_multi_proof_dos_large_leaf_count() {
        // Attacker sets massive leaf_count trying to cause DoS via memory allocation
        // The verify function should NOT allocate proportional to leaf_count
        let digests: Vec<Digest> = (0..4u32).map(|i| Sha256::hash(&i.to_le_bytes())).collect();

        let mut builder = Builder::<Sha256>::new(digests.len());
        for digest in &digests {
            builder.add(digest);
        }
        let tree = builder.build();
        let root = tree.root();
        let mut hasher = Sha256::default();

        // Generate valid proof
        let positions = [0, 2];
        let mut multi_proof = tree.multi_proof(&positions).unwrap();

        // Set massive leaf_count (attacker trying to exhaust memory)
        multi_proof.leaf_count = u32::MAX;

        let elements: Vec<(Digest, u32)> = positions
            .iter()
            .map(|&p| (digests[p as usize], p))
            .collect();

        // This should fail quickly without allocating massive memory
        // The function is O(elements * levels), not O(leaf_count)
        let result = multi_proof.verify_multi_inclusion(&mut hasher, &elements, &root);
        assert!(result.is_err(), "Should reject malicious large leaf_count");
    }

    #[cfg(feature = "arbitrary")]
    mod conformance {
        use super::*;
        use commonware_codec::conformance::CodecConformance;
        use commonware_cryptography::sha256::Digest as Sha256Digest;

        commonware_conformance::conformance_tests! {
            CodecConformance<RangeProof<Sha256Digest>>,
            CodecConformance<Bounds<Sha256Digest>>,
            CodecConformance<Proof<Sha256Digest>>,
        }
    }
}
