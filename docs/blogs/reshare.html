<!DOCTYPE html>
<html lang="en">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>commonware > Reconfiguration + Reshare with threshold consensus::simplex</title>
    <meta name="description" content="An ongoing challenge with maintaining distributed validator sets is reconfiguring the validator committee (adding and removing validators), and in turn, refreshing secret key material amongst active participants. Networks need to expand and contract the committee without pausing; Validator committees are rarely static in practice, e.g. to allow for staking/unstaking on Proof of Stake networks, or rotating the authorities on Proof of Authority networks.">
    <meta name="author" content="Ben Clabby">
    <meta name="keywords" content="commonware, open source, common goods, software, internet, ownership, trust, blockchain, decentralization, crypto">

    <meta property="og:url" content="https://commonware.xyz/blogs/reshare.html" />
    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="commonware" />
    <meta property="og:image" content="https://commonware.xyz/imgs/reshare.png" />
    <meta property="og:title" content="Reconfiguration + Reshare with threshold consensus::simplex" />
    <meta property="og:description" content="An ongoing challenge with maintaining distributed validator sets is reconfiguring the validator committee (adding and removing validators), and in turn, refreshing secret key material amongst active participants. Networks need to expand and contract the committee without pausing; Validator committees are rarely static in practice, e.g. to allow for staking/unstaking on Proof of Stake networks, or rotating the authorities on Proof of Authority networks." />
    <meta property="article:author" content="https://x.com/vex_0x" />
    <meta property="article:published_time" content="2025-10-15T00:00:00Z" />
    <meta property="article:modified_time" content="2025-10-15T00:00:00Z" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="commonware.xyz" />
    <meta property="twitter:url" content="https://commonware.xyz/blogs/reshare.html" />
    <meta property="twitter:title" content="Reconfiguration + Reshare with threshold consensus::simplex" />
    <meta property="twitter:description" content="An ongoing challenge with maintaining distributed validator sets is reconfiguring the validator committee (adding and removing validators), and in turn, refreshing secret key material amongst active participants. Networks need to expand and contract the committee without pausing; Validator committees are rarely static in practice, e.g. to allow for staking/unstaking on Proof of Stake networks, or rotating the authorities on Proof of Authority networks." />
    <meta property="twitter:image" content="https://commonware.xyz/imgs/reshare.png" />
    <meta property="twitter:site" content="@commonwarexyz" />
    <meta property="twitter:creator" content="@vex_0x" />

    <link rel="stylesheet" type="text/css" href="/style.css">
</head>

<body>
    <div id="logo-placeholder">
        <div class="logo-line">
            <span class="edge-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="edge-logo-symbol">*</span>
        </div>
        <div class="logo-line">
            <span class="vertical-logo-symbol">|</span>
            <span class="logo-text"> commonware </span>
            <span class="vertical-logo-symbol"> </span>
        </div>
        <div class="logo-line">
            <span class="edge-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="edge-logo-symbol">+</span>
        </div>
    </div>
    <div class="content">
        <h1>Once a Validator, Not Always a Validator</h1>
        <div class="meta">
            <div class="author">By <a href="https://x.com/vex_0x">Ben Clabby</a></div>
            <div class="date">October 15, 2025</div>
        </div>
        <p>
            Most consensus protocols, from <a href="https://arxiv.org/abs/1807.04938">Tendermint</a> and <a href="https://arxiv.org/abs/1803.05069">HotStuff</a> to our own
            <a href="https://arxiv.org/abs/2508.10862"><code>minimmit</code></a>, are defined under a "permissioned" model where the validator set is fixed and known ahead of time
            by all participants. Safely transitioning from one committee to the next, where validators can be added and removed, is left as an exercise to the implementer.
        </p>
        <p>
            Tendermint-style protocols make the transition straightforward: replicas only build height <code>h + 1</code> once height <code>h</code> is finalized,
            so swapping the validator list during finalization is safe. Newer protocols, like <code>consensus::simplex</code>,
            begin casting votes for the next height immediately after the previous height is notarized. That faster-than-finality pipeline drives latency down,
            but it complicates reconfiguration. If validators disagree about who is eligible to notarize a block, the network risks a halt or a safety failure.
        </p>
        <p>
            So how do we reconfigure without pausing? A recent formulation by Jovan Komatovic, Andrew Lewis-Pye, Joachim Neu,
            Tim Roughgarden, and Ertem Nusret Tas in <a href="https://arxiv.org/pdf/2506.14124"><i>From Permissioned to Proof-of-Stake Consensus</i></a>
            offers a protocol-agnostic answer. Treat the replicated log as a sequence of epoch-sized segments and only advance to the next segment when
            the block at the epoch boundary is directly finalized. The technique black-boxes the inner consensus engine, so the same recipe works no matter
            how blocks are notarized.
        </p>
        <p>
            With an eye towards supporting multiple consensus protocols in the Commonware Library&mdash;including
            <a href="/blogs/minimmit.html"><code>minimmit</code></a> and <a href="/blogs/threshold-simplex.html"><code>consensus::simplex</code></a>&mdash;we implemented this approach.
            Height-based epoching in <code>consensus::simplex</code> adds an explicit <code>epoch</code> field to every message and lets an orchestrator advance epochs
            once the last block in the current epoch is directly finalized. Epoch boundaries give us the perfect place to reshare BLS key material and hand the signing
            authority to the next committee without introducing side channels.
        </p>
        <div class="image-container">
            <img src="/imgs/epoching.png" alt="Epoching" />
            <div class="image-caption">Figure 1: After some configurable number of blocks is finalized, a new epoch begins. If more blocks than desired are finalized, they are dropped. Epochs require direct finalization of the last block to advance,
                if this hasn't happened yet we repropose the same block. The last block of some epoch is treated as the genesis block of the next epoch.
            </div>
        </div>
        <h2>Resharing: Piggybacking on Consensus</h2>
        <p>
            In the threshold setting, changing the validator set means more than updating a list. Fresh participants need a share of the threshold secret to sign votes,
            and existing participants must refresh their shares to avoid accumulating risk. Our original
            <a href="https://github.com/commonwarexyz/monorepo/tree/main/examples/vrf"><code>vrf</code></a> example showed a continuous reshare pipeline,
            but it relied on a central <a href="https://docs.rs/commonware-cryptography/latest/commonware_cryptography/bls12381/dkg/arbiter/struct.Arbiter.html">Arbiter</a>
            to keep everyone honest. Removing that trusted coordinator requires piggybacking resharing directly on top of consensus.
        </p>
        <p>
            Threshold <code>consensus::simplex</code> uses BLS threshold signatures so a committee can sign votes as a single aggregate.
            Each validator holds a share of the private key, and as soon as <code>T</code> shares are combined the signature verifies under the group public key.
            That structure is ideal for fast notarization, but it only works if every active validator possesses a fresh, matching share.
        </p>
        <p>
            Our new <a href="https://github.com/commonwarexyz/monorepo/tree/main/examples/reshare"><code>reshare</code></a> example
            marries the DKG engine in <code>cryptography::bls12381::dkg</code> with the replicated log of a blockchain.
            Validators refresh their key material every epoch&mdash;a configurable interval of blocks&mdash;and derive new shares for incoming participants.
            The consensus log carries the entire transcript so that chains using threshold <code>consensus::simplex</code> can reconfigure committees without an out-of-band channel.
        </p>
        <p>
            Each epoch begins with a set of <b>dealers</b>, the validators currently signing blocks, and <b>players</b>, the validators who will sign in the next epoch.
            Dealers publish encrypted shares, Feldman commitments, and optional complaints to the log. Players acknowledge or challenge those shares, and any misbehavior is
            surfaced as evidence. Once the outcomes converge, the orchestrator packages the transcript into a compact <code>Outcome</code> object and proposes it alongside normal blocks.
        </p>
        <p>
            Consensus handles the rest. When the reshare outcomes finalize, every node&mdash;whether or not it currently holds a share&mdash;derives the same commitments,
            optional local key material, and the participant list for the next epoch. Instead of trusting an Arbiter as in the
            <code>vrf</code> example, every player independently validates the dealers' work from the data replicated on chain.
        </p>
        <div class="image-container">
            <img src="/imgs/reshare_actors.png" alt="Actor Interactions" />
            <div class="image-caption">Figure 2: Dealers and Players interact with each other and the replicated log to derive the new shares and group polynomial.</div>
        </div>
        <p>
            Driving resharing through the replicated log gives us three concrete properties:
        </p>
        <ol>
            <li><b>Accountability</b>: every dealer's encrypted share, commitment, and complaint live in the log as a durable receipt.</li>
            <li><b>Availability</b>: the network keeps proposing blocks while it prepares the next quorum, so reconfiguration never competes with liveness.</li>
            <li><b>Recoverability</b>: because dealer outcomes are persisted, any node can crash, restart, and deterministically rejoin the current epoch without side-channel communication.</li>
        </ol>
        <h2>Bootstrapping a Threshold Committee</h2>
        <p>
            The example ships with two bootstrap strategies. A trusted coordinator can mint the genesis key set and hand
            the shares to validators, or the validators can run a DKG ceremony to generate the initial shares
            collectively.
        </p>
        <p>
            The trusted path is the quickest on-ramp for experimentation: the setup tool deterministically samples the
            group key, splits it into shares, and writes configs for each validator. The DKG ceremony takes longer but
            eliminates that single point of trust. A bootstrap committee uses ED25519
            <code>consensus::simplex</code> to agree on the transcript produced by
            <code>cryptography::bls12381::dkg</code>, and the resulting shares flow into the very first epoch.
        </p>
        <img src="/imgs/dkg_bootstrap.png" alt="DKG bootstrap" />
        <p>
            After this process is complete, the initial epoch's committee can begin producing blocks under threshold
            <code>consensus::simplex</code>.
        </p>

        <h2>Trying It Locally</h2>
        <p>
            You can run the example by generating participant configurations and launching the validators with the
            command emitted by the setup step. Within a few minutes the logs will show share distributions, resumed
            consensus rounds, and epoch transitions as the network continually rotates the committee with refreshed
            shares.
        </p>
        <pre><code>
$ git clone git@github.com:commonwarexyz/monorepo.git && cd monorepo
# Trusted Setup
$ cargo run --bin commonware-reshare setup
# DKG Setup
$ cargo run --bin commonware-reshare setup --with-dkg
# Execute the `mprocs` command(s) emitted by the previous step
        </code></pre>
        <p>
            The setup step writes per-validator configuration files under the chosen <code>--datadir</code> (default <code>./data</code>)
            and prints one or two <code>mprocs</code> invocations. For the DKG flow, run the first command to complete the ceremony,
            shut everything down, and then run the second command to launch the threshold committee that was just minted.
        </p>

        <h2>What Comes Next</h2>
        <p>
            We expect builders to use their own selection rules, plug the reshare transcript into application state,
            and experiment with various reconfiguration cadences. If you take the example in a new direction, or uncover
            interesting corner cases, let us know. Validator networks should be able to evolve securely in real time,
            and this example is an invitation to make that the default.
        </p>
    </div>

    <div id="footer-placeholder"></div>
    <script src="/shared.js"></script>
</body>

</html>