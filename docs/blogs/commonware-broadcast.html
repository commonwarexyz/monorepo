<!DOCTYPE html>
<html lang="en">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <link rel="icon" href="../favicon.ico" type="image/x-icon">

    <title>commonware > Merkle Mountain Ranges for Performant Data Authentication</title>
    <meta name="description" content="Decentralized systems require the ability to prove authenticity of data received from potentially untrustworthy sources. The most well known data structure for this task is the Merkle tree, which allows one to efficiently prove inclusion of an element within a list without having to obtain the entire list from a trusted source.">
    <meta name="author" content="Roberto Bayardo">
    <meta name="keywords" content="commonware, open source, common goods, software, internet, ownership, trust, blockchain, decentralization, crypto">

    <meta property="og:url" content="https://commonware.xyz/blogs/mmr.html" />
    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="commonware" />
    <meta property="og:image" content="https://commonware.xyz/imgs/mmr.png" />
    <meta property="og:title" content="Merkle Mountain Ranges for Performant Data Authentication" />
    <meta property="og:description" content="Decentralized systems require the ability to prove authenticity of data received from potentially untrustworthy sources. The most well known data structure for this task is the Merkle tree, which allows one to efficiently prove inclusion of an element within a list without having to obtain the entire list from a trusted source." />
    <meta property="article:author" content="https://x.com/roberto_bayardo" />
    <meta property="article:published_time" content="2025-02-13T00:00:00Z" />
    <meta property="article:modified_time" content="2025-02-13T00:00:00Z" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="commonware.xyz" />
    <meta property="twitter:url" content="https://commonware.xyz/blogs/mmr.html" />
    <meta property="twitter:title" content="Merkle Mountain Ranges for Performant Data Authentication" />
    <meta property="twitter:description" content="Decentralized systems require the ability to prove authenticity of data received from potentially untrustworthy sources. The most well known data structure for this task is the Merkle tree, which allows one to efficiently prove inclusion of an element within a list without having to obtain the entire list from a trusted source." />
    <meta property="twitter:image" content="https://commonware.xyz/imgs/mmr.png" />
    <meta property="twitter:site" content="@commonwarexyz" />
    <meta property="twitter:creator" content="@roberto_bayardo" />

    <link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>
    <div id="logo-placeholder">
        <div class="logo-line">
            <span class="edge-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="edge-logo-symbol">*</span>
        </div>
        <div class="logo-line">
            <span class="vertical-logo-symbol">|</span>
            <span class="logo-text"> commonware </span>
            <span class="vertical-logo-symbol"> </span>
        </div>
        <div class="logo-line">
            <span class="edge-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="edge-logo-symbol">+</span>
        </div>
    </div>
    <div class="content">
        <h1>TBD</h1>
        <div class="meta">
            <div class="author">By <a href="https://x.com/b_chou">Brendan Chou</a></div>
            <div class="date">February 20, 2025</div>
        </div>
        <p>Decentralized networks require replicating data across nodes—but doing it efficiently and reliably is a challenge. Gossip-based mempools are typically best-effort, which results in significant wasted bandwidth due to delivery uncertainty. All-to-leader-to-all systems are more efficient, but they channel all messages through a single node. This fails to saturate the bandwidth of the network and suffers degraded throughput whenever a leader is unresponsive. The result? Performance bottlenecks that are a nightmare to optimize and debug.</p>
        <p>Enter <i>commonware-broadcast</i>. Our latest primitive provides a common interface for data dissemination, with multiple “dialects” tailored around different tradeoffs. The first dialect, <i>broadcast::linked</i>, uses a high-throughput, fault-tolerant, and ordered approach to messaging that efficiently integrates with consensus mechanisms using threshold cryptography.</p>
        <p>Let’s break it down.</p>
        <p>This dialect specifies two roles in the network: sequencers who initiate and order messages, and validators who verify and acknowledge messages. Membership in the sets is arbitrary; the set of sequencers and validators may overlap or be completely distinct. When used in a blockchain setting, the set of broadcast validators may or may not match the set of block validators.</p>
        <p>Validators acknowledge receipt and validate messages by emitting partial signatures. These partial signatures are aggregated into threshold signatures once a quorum is reached.</p>
        <p>For sequencers, each new message must also carry the threshold signature of the previous message in the sequencer's history. By induction, a single threshold signature provides cryptographic proof of the existence of the entire history of linked messages. That is, each previous message is guaranteed to have been validated by a quorum of validators. Credit goes to <a href="https://arxiv.org/abs/2401.10369">Autobahn</a>, which introduces the idea that certified messages—when linked—imply a complete, valid, and well-replicated history of messages.</p>
        <div class="image-container">
            <img src="../imgs/linked-broadcast.png" alt="Sequencer broadcasting messages, linking each to the previous one using threshold signatures.">
            <div class="image-caption">Figure 1: A diagram of a sequencer broadcasting messages, linking each to the previous one using threshold signatures. Multiple validators are contributing partial signatures.</div>
        </div>
        <p>The formation of threshold signatures over each message has powerful implications.</p>
        <ol>
            <li>With just the latest message (i.e. the tip) of each sequencer, participants know that all previous messages have been broadcast and validated. This lets them begin syntactic verification of any new messages, while backfilling all missing messages in parallel. This enables efficient recovery from node failures or temporary network disruption, or efficient startup for nodes coming online for the first time.</li>
            <li>Broadcast is decoupled from consensus. Consensus can finalize—in “one shot”—the entirety of all unfinalized messages by including the certified tip of each sequencer. This results in massive throughput. Broadcast can be parallelized with multiple sequencers without being blocked by consensus—even by a single-leader mechanism. Finalization via consensus then requires only a tiny amount of data per sequencer.</li>
            <li>The threshold signature serves as a pre-consensus receipt of inclusion. Partial signatures are broadcast to all other validators as well as the sequencer, allowing any of these parties to construct the threshold signature. The threshold signature guarantees that the message becomes an immutable part of the sequencer’s history, and thus that it will eventually be included in consensus.</li>
        </ol>
        <div class="image-container">
            <img src="../imgs/broadcast-in-consensus.png" alt="Every block references a set of sequencer tips, each with a threshold signature.">
            <div class="image-caption">Figure 2: A diagram showing how broadcast messages may be used in consensus. Every block references a set of sequencer tips, each with a threshold signature.</div>
        </div>
        <p><i>broadcast::linked<i> also handles set reconfiguration. It is robust in the face of changing participants across epochs—distinct periods when the set of validators and sequencers may change. During changes, the aggregate set of validators must still be able to produce a threshold signature using the same threshold public key. Meanwhile, the set of sequencers may change arbitrarily. For example, the system might modify the number of active sequencers or remove and later reinstate them.</p>
        <p>Sequencer tips are stored robustly in a write-ahead log, ensuring consistency even in the face of unexpected node shutdown. This prevents honest sequencers from broadcasting conflicting messages and also prevents honest validators from signing conflicting messages from dishonest sequencers. Conflicting messages are messages with the same sequencer and height that contain different data.</p>
        <p>As with other Commonware components, this dialect is tested for resilience using Commonware’s <a href="https://commonware.xyz/commonware-runtime.html">deterministic test suite</a>. It simulates complex scenarios such as probabilistic packet loss, complete node failure, and temporary network partitions.</p>
        <p>In summary, for developers building decentralized applications, broadcast::linked enables high-throughput using multiple sequencers and a simple, easily verifiable structure over message dissemination. Its use of threshold signatures proves the integrity of an entire history of messages, allowing for fast, succinct validation by clients and guaranteeing inclusion for users. If you need any or all of the above, broadcast::linked delivers an efficient and elegant solution.</p>
        <p>It should be noted that broad, public dissemination of threshold signatures and data is outside this scope. However, the modular design of Commonware primitives makes this easy to implement in whatever way is optimal for your application.</p>
        <p>To keep diving deeper, check out the <a href="https://docs.rs/commonware-broadcast/latest">commonware-broadcast documentation</a>.</p>
    </div>

    <div id="footer-placeholder"></div>
    <script src="../shared.js"></script>
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "07159b86f75b4af18e54dd0cda2fb4a7"}'></script>
</body>

</html>