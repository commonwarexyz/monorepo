<!DOCTYPE html>
<html lang="en">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <link rel="preload" href="/style.css" as="style">
    <link rel="preload" href="/shared.js" as="script">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>commonware > It’s a Grind</title>
    <meta name="description" content="Authenticated databases use tree
structures like tries, binary search trees, and BTrees to support fast
key lookup and generate a verifiable state (known as ‘merkleizing’).
These structures work best when the keys are spread out evenly
(uniformly distributed), and performance can suffer otherwise.">
    <meta name="author" content="Roberto Bayardo">
    <meta name="keywords" content="commonware, open source, common goods, software, internet, ownership, trust, blockchain, decentralization, crypto">

    <meta property="og:url" content="https://commonware.xyz/blogs/its-a-grind" />
    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="commonware" />
    <meta property="og:image" content="https://commonware.xyz/imgs/compressed-index.png" />
    <meta property="og:title" content="It’s a Grind" />
    <meta property="og:description" content="Authenticated databases use
tree structures like tries, binary search trees, and BTrees to support
fast key lookup and generate a verifiable state (known as
‘merkleizing’). These structures work best when the keys are spread out
evenly (uniformly distributed), and performance can suffer
otherwise." />
    <meta property="article:author" content="Roberto Bayardo" />
    <meta property="article:published_time" content="2026-02-27T00:00:00Z" />
    <meta property="article:modified_time" content="2026-02-27T00:00:00Z" />

    <link rel="canonical" href="https://commonware.xyz/blogs/its-a-grind" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="commonware.xyz" />
    <meta property="twitter:url" content="https://commonware.xyz/blogs/its-a-grind" />
    <meta property="twitter:title" content="It’s a Grind" />
    <meta property="twitter:description" content="Authenticated
databases use tree structures like tries, binary search trees, and
BTrees to support fast key lookup and generate a verifiable state (known
as ‘merkleizing’). These structures work best when the keys are spread
out evenly (uniformly distributed), and performance can suffer
otherwise." />
    <meta property="twitter:image" content="https://commonware.xyz/imgs/compressed-index.png" />
    <meta property="twitter:site" content="@commonwarexyz" />
        <meta property="twitter:creator" content="https://x.com/roberto_bayardo" />
    
    <link rel="stylesheet" type="text/css" href="/style.css">

    </head>

<body>
    <div id="logo-placeholder">
        <div class="logo-line">
            <span class="edge-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="edge-logo-symbol">*</span>
        </div>
        <div class="logo-line">
            <span class="vertical-logo-symbol">|</span>
            <span class="logo-text"> commonware </span>
            <span class="vertical-logo-symbol"> </span>
        </div>
        <div class="logo-line">
            <span class="edge-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">~</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">+</span>
            <span class="horizontal-logo-symbol"> </span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="horizontal-logo-symbol">*</span>
            <span class="horizontal-logo-symbol">-</span>
            <span class="edge-logo-symbol">+</span>
        </div>
    </div>
    <div class="content">
        <h1>It’s a Grind</h1>
        <div class="meta">

                        <div class="author">By <a href="https://x.com/roberto_bayardo">Roberto
Bayardo</a></div>
                        <div class="date">February 27th, 2026</div>
        </div>
        <p>Authenticated databases use tree structures like tries,
        binary search trees, and BTrees to support fast key lookup and
        generate a verifiable state (known as ‘merkleizing’). These
        structures work best when the keys are spread out evenly
        (uniformly distributed), and performance can suffer
        otherwise.</p>
        <p>In adversarial environments such as those faced by
        permissionless blockchains, key uniformity is unfortunately not
        guaranteed. If you’ve been in crypto for any amount of time,
        your wallet’s activity history almost certainly contains at
        least one transaction that involves an address you might believe
        you’ve interacted with in the past, but actually differs in
        bytes elided from an abbreviated rendering.</p>
        <figure>
        <img src="/imgs/address-poisoning.jpeg"
        alt="Address poisoning exploits the fact that wallet addresses are rarely rendered in full." />
        <figcaption aria-hidden="true">Address poisoning exploits the
        fact that wallet addresses are rarely rendered in
        full.</figcaption>
        </figure>
        <p>This is the classic <a
        href="https://support.metamask.io/stay-safe/protect-yourself/wallet-and-hardware/address-poisoning-scams"><em>address
        poisoning</em></a> attack (Figure 1), where the attacker profits
        from the chance you might copy and paste the address when
        sending funds to, say, what you think is your exchange’s deposit
        address.</p>
        <p>Poisoned addresses are produced through a computationally
        expensive procedure called <em>grinding</em>. But grinding isn’t
        limited to account addresses – an attacker can grind keys that
        satisfy many kinds of properties given the incentive and access
        to enough compute power.</p>
        <p>Consider the <em>trie</em> structure, a type of search tree
        where a lookup requires traversing exactly k nodes from root to
        leaf, where k is the number of chosen key segments
        (e.g. characters, bytes, nibbles). No amount of key grinding
        will affect search depth in a trie! But the downside is that
        search depth is unconditionally poor. A typical key size in a
        blockchain state database is 32 bytes. Even with an unusually
        large key segment size of 1 byte (1 nibble is more common), we
        unconditionally traverse 32 nodes per lookup. Traversing 32
        nodes per lookup may not seem like much, but if the structure’s
        nodes are scattered randomly across secondary storage, the
        result can be impractically slow.</p>
        <figure>
        <img src="/imgs/radix-tree.png"
        alt="A trie and its compressed counterpart storing “cat”, “card”, “carts”, and “dog”." />
        <figcaption aria-hidden="true">A trie and its compressed
        counterpart storing “cat”, “card”, “carts”, and
        “dog”.</figcaption>
        </figure>
        <p>Many applications build on compressed versions of the trie
        such as the <em>Patricia</em> trie (aka radix tree) to reduce
        the average number of node traversals per lookup. The Patricia
        trie stores “extension nodes” that collapse a lengthy path into
        a single node if it terminates in only one descendant (fig 2).
        This optimization reduces the number of levels that must be
        traversed from exactly k to ~log_2(n), where n is the number of
        elements stored within it – at least under the assumption that
        keys are uniformly distributed. But as we pointed out earlier,
        there’s no such uniformity guarantee in the wild west of
        permissionless blockchains. An attacker could, for example,
        grind out keys that introduce child nodes all along a previously
        compressed path, reverting its compression and pushing the
        average case number of traversals towards the worst case (see <a
        href="https://www.computer.org/csdl/proceedings-article/sp/2024/313000a125/1Ub23FE54kw">Nurgle</a>
        for a detailed analysis).</p>
        <p>Another structure susceptible to grinding attacks is the
        hashtable. With knowledge of the hash function, an attacker can
        grind out many keys that all hash to the same bucket to increase
        the CPU required to fetch keys within it – a classic denial of
        service vector for many internet services over the years. As a
        result, modern hashtable implementations will (unless otherwise
        configured) randomly seed the hash function at startup,
        preventing an attacker from knowing if any two keys might
        collide.</p>
        <p>So, how do we at Commonware deal with grinding attacks?
        Commonware’s authenticated databases, like <a
        href="/blogs/adb-any">qmdb::any</a>, use a Merkle Mountain Range
        (MMR) over database operations for the canonical structure. A
        Merkle mountain range is a tree structure with the property that
        its <em>maximum</em> (not average) leaf depth is log2(n) where n
        is the number of operations. Grind all you want, your node’s
        depth won’t be affected (it’s independent of the key’s
        content)!</p>
        <p>But an MMR alone doesn’t allow for efficient key lookups, so
        QMDB couples the canonical MMR with a <em>memory efficient
        index</em> that maps keys to their values on disk. By decoupling
        fast key lookup from merkleization, the exact structure of the
        index need not be canonical, allowing flexibility in its
        instantiation.</p>
        <figure>
        <img src="/imgs/compressed-index.png"
        alt="Key translation for memory efficient indexing." />
        <figcaption aria-hidden="true">Key translation for memory
        efficient indexing.</figcaption>
        </figure>
        <p>In QMDB, the index stores only a shortened (aka “translated”)
        representation of each key to reduce memory (fig. 3). Even if
        raw keys are the result of a cryptographic hash, if the key
        translation function is known, the index would be susceptible to
        grinding attacks that generate collisions among translated keys
        and degrade performance. Much as a good hashtable implementation
        will randomize its hash function, the Commonware index can be
        instantiated with a <a
        href="https://github.com/commonwarexyz/monorepo/blob/4870589ea077a1170b9747e305f83ea7592b621d/storage/src/translator.rs#L191">translator</a>
        that applies a randomly-seeded hash per instance. Even if the
        unlikely event an adversary learns the seed of one validator, it
        would differ from that of all others, providing the entire
        network strong immunity against DoS attacks from state key
        grinding.</p>
        <div id="footer-placeholder"></div>
        <script src="/shared.js"></script>
</body>

</html>