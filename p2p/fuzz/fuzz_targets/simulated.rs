#![no_main]

use arbitrary::Arbitrary;
use bytes::Bytes;
use commonware_codec::codec::FixedSize;
use commonware_cryptography::{ed25519, PrivateKeyExt, Signer};
use commonware_p2p::{
    simulated::{self},
    Channel, Receiver as ReceiverTrait, Recipients, Sender as SenderTrait,
};
use commonware_runtime::{deterministic, Clock, Metrics, Runner};
use libfuzzer_sys::fuzz_target;
use rand::Rng;
use std::{
    collections::{HashMap, HashSet, VecDeque},
    time::Duration,
};

const MAX_OPERATIONS: usize = 50;
const MAX_PEERS: usize = 16;
const MAX_SLEEP_DURATION: u64 = 1000;
const MAX_MSG_SIZE: usize = 1024 * 1024; // 1MB

/// Operations that can be performed on the simulated p2p network during fuzzing.
#[derive(Debug, Arbitrary)]
enum Operation {
    /// Register a new channel for a peer to send/receive messages.
    RegisterChannel {
        /// Index of the peer registering the channel.
        peer_idx: u8,
        /// Channel identifier
        channel_id: u8,
    },
    /// Send a message from one peer to another on a specific channel.
    SendMessage {
        /// Index of the peer sending the message.
        peer_idx: u8,
        /// Channel to send the message on.
        channel_id: u8,
        /// Index of the recipient peer.
        to_idx: u8,
        /// Size of the message payload in bytes.
        msg_size: usize,
    },
    /// Attempt to receive pending messages from all peers.
    ReceiveMessages,
    /// Add or update a network link between two peers with specific characteristics.
    AddLink {
        /// Index of the sender peer.
        from_idx: u8,
        /// Index of the receiver peer.
        to_idx: u8,
        /// Base latency in milliseconds.
        latency_ms: u16,
        /// Latency jitter in milliseconds.
        jitter: u16,
        /// Success rate (0-255 maps to 0.0-1.0).
        success_rate: u8,
    },
    /// Remove a network link between two peers.
    RemoveLink {
        /// Index of the sender peer.
        from_idx: u8,
        /// Index of the receiver peer.
        to_idx: u8,
    },
}

/// Input generated by the fuzzer for testing the simulated p2p network.
#[derive(Debug)]
struct FuzzInput {
    /// Random seed for deterministic execution.
    seed: u64,
    /// Sequence of operations to execute on the network.
    ///
    /// Length is in the range [1, MAX_OPERATIONS].
    operations: Vec<Operation>,
    /// Number of peers to create in the network.
    ///
    /// Must be in the range [2, MAX_PEERS].
    num_peers: u8,
}

impl<'a> Arbitrary<'a> for FuzzInput {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let seed = u.arbitrary()?;
        let num_operations = u.int_in_range(1..=MAX_OPERATIONS)?;
        let mut operations = Vec::with_capacity(num_operations);
        for _ in 0..num_operations {
            operations.push(u.arbitrary()?);
        }
        let num_peers = u.int_in_range(2..=MAX_PEERS)? as u8;
        Ok(FuzzInput {
            seed,
            operations,
            num_peers,
        })
    }
}

/// Main fuzzing entry point for testing the simulated p2p network.
///
/// Creates a deterministic network and executes a sequence of random operations,
/// verifying that received messages match expectations.
fn fuzz(input: FuzzInput) {
    let num_peers = input.num_peers;

    let p2p_cfg = simulated::Config {
        max_size: MAX_MSG_SIZE,
        disconnect_on_block: false,
    };

    let executor = deterministic::Runner::seeded(input.seed);
    executor.start(|mut context| async move {
        // Generate peer identities
        let mut peers = Vec::new();
        for _ in 0..num_peers {
            let private_key = ed25519::PrivateKey::from_seed(context.gen());
            peers.push(private_key.public_key());
        }

        // Create the simulated network and oracle for controlling it
        let (network, mut oracle) = simulated::Network::new(context.with_label("network"), p2p_cfg);
        let network_handler = network.start();

        // Track registered channels: (peer_idx, channel_id) -> (sender, receiver)
        let mut channels: HashMap<
            (usize, u8),
            (
                commonware_p2p::simulated::Sender<ed25519::PublicKey>,
                commonware_p2p::simulated::Receiver<ed25519::PublicKey>,
            ),
        > = HashMap::new();

        // Track which (peer, channel) combinations are already registered
        let mut registered_peer_channels = HashSet::new();

        // Track expected messages: (receiver_idx, sender_pk, channel_id) -> queue of messages
        // Messages may be dropped (unreliable links) but those delivered must match expectations
        let mut expected: HashMap<(usize, ed25519::PublicKey, u8), VecDeque<Bytes>> = HashMap::new();

        for op in input.operations.into_iter() {
            match op {
                Operation::RegisterChannel {
                    peer_idx,
                    channel_id,
                } => {
                    // Normalize peer index to valid range
                    let idx = (peer_idx as usize) % peers.len();
                    let key = (idx, peers[idx].clone(), channel_id);

                    // Only register if not already registered
                    if !registered_peer_channels.contains(&key) {
                        if let Ok((sender, receiver)) =
                            oracle.register(peers[idx].clone(), channel_id as u64).await
                        {
                            channels.insert((idx, channel_id), (sender, receiver));
                            registered_peer_channels.insert(key);
                        }
                    }
                }

                Operation::SendMessage {
                    peer_idx,
                    channel_id,
                    to_idx,
                    msg_size,
                } => {
                    // Normalize indices to valid ranges
                    let from_idx = (peer_idx as usize) % peers.len();
                    let to_idx = (to_idx as usize) % peers.len();

                    // Clamp message size to not exceed max (accounting for channel overhead)
                    let msg_size = msg_size.clamp(0, MAX_MSG_SIZE - Channel::SIZE);

                    // Skip if sender channel not registered
                    let Some((ref mut sender, _)) = channels.get_mut(&(from_idx, channel_id))
                    else {
                        continue;
                    };

                    // Generate random message payload
                    let mut bytes = vec![0u8; msg_size];
                    context.fill(&mut bytes[..]);
                    let message = Bytes::from(bytes);

                    // Attempt to send the message
                    // Note: Success only means accepted for transmission, not guaranteed delivery
                    let res = sender
                        .send(
                            Recipients::One(peers[to_idx].clone()),
                            message.clone(),
                            true,
                        )
                        .await;

                    // Track message as expected only if send was accepted
                    // Message may still be dropped by unreliable link
                    if res.is_ok() {
                        expected
                            .entry((to_idx, peers[from_idx].clone(), channel_id))
                            .or_default()
                            .push_back(message);
                    }
                }

                Operation::ReceiveMessages => {
                    // Attempt to receive messages from all peers with pending messages
                    let expected_keys: Vec<_> = expected.keys().cloned().collect();
                    for (to_idx, real_sender_id, channel_id) in expected_keys {
                        // Skip if receiver channel not registered
                        let Some((_, ref mut receiver)) = channels.get_mut(&(to_idx, channel_id))
                        else {
                            continue;
                        };

                        // Skip if no expected messages for this combination
                        let Some(queue) = expected.get_mut(&(to_idx, real_sender_id.clone(), channel_id)) else {
                            continue;
                        };

                        // Try to receive one message with a timeout
                        commonware_macros::select! {
                            result = receiver.recv() => {
                                if let Ok((recv_sender_id, message)) = result {
                                    // Search for this message in the expected queue
                                    // Note: Messages may arrive out of order
                                    if let Some(pos) = queue.iter().position(|m: &Bytes| m == &message) {
                                        queue.remove(pos);

                                        // Verify sender identity matches
                                        if recv_sender_id != real_sender_id {
                                            panic!("Message sender: {recv_sender_id}, but real sender: {real_sender_id}");
                                        }

                                        // Clean up empty queues
                                        if queue.is_empty() {
                                            expected.remove(&(to_idx, real_sender_id, channel_id));
                                        }
                                    } else {
                                        panic!("Message not found in expected queue");
                                    }
                                }
                            },
                            _ = context.sleep(Duration::from_millis(MAX_SLEEP_DURATION)) => {
                                // Timeout: message didn't arrive, may have been dropped
                                continue;
                            }
                        }
                    }
                }

                Operation::AddLink {
                    from_idx,
                    to_idx,
                    latency_ms,
                    jitter,
                    success_rate,
                } => {
                    // Normalize indices to valid ranges
                    let from_idx = (from_idx as usize) % peers.len();
                    let to_idx = (to_idx as usize) % peers.len();

                    // Create link with specified characteristics
                    // success_rate is normalized from u8 (0-255) to f64 (0.0-1.0)
                    let link = simulated::Link {
                        latency: Duration::from_millis(latency_ms as u64),
                        jitter: Duration::from_millis(jitter as u64),
                        success_rate: (success_rate as f64) / 255.0,
                    };
                    let _ = oracle
                        .add_link(peers[from_idx].clone(), peers[to_idx].clone(), link)
                        .await;
                }

                Operation::RemoveLink { from_idx, to_idx } => {
                    // Normalize indices to valid ranges
                    let from_idx = (from_idx as usize) % peers.len();
                    let to_idx = (to_idx as usize) % peers.len();

                    // Remove link to simulate network partition
                    let _ = oracle
                        .remove_link(peers[from_idx].clone(), peers[to_idx].clone())
                        .await;
                }
            }
        }

        // Clean up network handler before exiting
        network_handler.abort();
    });
}

fuzz_target!(|input: FuzzInput| {
    fuzz(input);
});
