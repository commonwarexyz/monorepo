use arbitrary::Arbitrary;
use bytes::Bytes;
use commonware_codec::codec::FixedSize;
use commonware_cryptography::{ed25519, PrivateKeyExt, Signer};
use commonware_p2p::{
    authenticated::{
        discovery,
        lookup::{self, Network as LookupNetwork},
    },
    Blocker, Channel, Receiver, Recipients, Sender,
};
use commonware_runtime::{deterministic, deterministic::Context, Clock, Handle, Metrics, Runner};
use commonware_utils::NZU32;
use governor::Quota;
use rand::{seq::SliceRandom, Rng};
use std::{
    collections::{HashMap, HashSet, VecDeque},
    future::Future,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    time::Duration,
};

const MAX_OPERATIONS: usize = 30;
const MAX_PEERS: usize = 8;
const MIN_PEERS: usize = 4;
const MAX_MSG_SIZE: usize = 1024 * 1024;
const MAX_INDEX: u8 = 10;
const PEER_SUBSET_NUMBER: usize = 5;
const DEFAULT_MESSAGE_BACKLOG: usize = 128;
const MAX_SLEEP_DURATION: u64 = 1000;

/// Modes for selecting message recipients during fuzzing.
#[derive(Debug, Arbitrary)]
pub enum RecipientMode {
    /// Send to all peers except the sender.
    All,
    /// Send to exactly one peer.
    One,
    /// Send to a random subset of peers.
    Some,
}

/// Operations that can be performed on the p2p network during fuzzing.
#[derive(Debug, Arbitrary)]
pub enum NetworkOperation {
    /// Send a message from one peer to one or more recipients.
    SendMessage {
        /// Index of the peer sending the message.
        sender_idx: u8,
        /// How to select recipients.
        recipient_mode: RecipientMode,
        /// Index of the recipient peer (used for `RecipientMode::One`).
        recipient_idx: u8,
        /// Size of the message payload in bytes.
        msg_size: usize,
    },
    /// Attempt to receive messages from any peers with pending messages.
    ReceiveMessages,
    /// Register a subset of peers under a specific index.
    RegisterPeers {
        /// Index of the peer whose oracle will register the subset.
        peer_idx: u8,
        /// The index to register the peer subset under.
        index: u8,
        /// Number of peers to include in the subset.
        num_peers: u8,
    },
    /// Block a target peer from sending messages to the blocking peer.
    BlockPeer {
        /// Index of the peer that will block the target.
        peer_idx: u8,
        /// Index of the peer to be blocked.
        target_idx: u8,
    },
}

/// Input generated by the fuzzer for testing p2p networks.
#[derive(Debug)]
pub struct FuzzInput {
    /// Random seed for deterministic execution.
    pub seed: u64,
    /// Sequence of operations to execute on the network.
    ///
    /// Length is in the range [1, MAX_OPERATIONS].
    pub operations: Vec<NetworkOperation>,
    /// Number of peers to create in the network.
    ///
    /// Must be in the range [MIN_PEERS, MAX_PEERS].
    pub peers: u8,
}

impl<'a> Arbitrary<'a> for FuzzInput {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let seed = u.arbitrary()?;
        let num_operations = u.int_in_range(1..=MAX_OPERATIONS)?;
        let mut operations = Vec::with_capacity(num_operations);
        for _ in 0..num_operations {
            operations.push(u.arbitrary()?);
        }
        let peers = u.int_in_range(MIN_PEERS..=MAX_PEERS)? as u8;
        Ok(FuzzInput {
            seed,
            operations,
            peers,
        })
    }
}

/// Information about a peer in the network.
pub struct PeerInfo {
    /// The peer's private key.
    pub private_key: ed25519::PrivateKey,
    /// The peer's public key .
    pub public_key: ed25519::PublicKey,
    /// The network address where this peer can be reached.
    pub address: SocketAddr,
}

/// A network with a sender, receiver, oracle, and handle.
pub struct Network<S, R, O> {
    /// Sender for sending messages to other peers.
    pub sender: S,
    /// Receiver for receiving messages from other peers.
    pub receiver: R,
    /// Oracle for controlling the network (registering peers, blocking, etc.).
    pub oracle: O,
    /// Handle to the running network task that can be aborted.
    pub handle: Handle<()>,
}

/// All information and components for a single peer.
pub struct Peer<S, R, O> {
    /// Peer information (keys and address).
    pub info: PeerInfo,
    /// Network components for this peer.
    pub network: Network<S, R, O>,
}

/// Trait for abstracting over different p2p network implementations (Discovery, Lookup) during fuzzing.
///
/// This allows the same fuzzing logic to test multiple network implementations by providing
/// a common interface for network creation and peer registration.
pub trait NetworkScheme: Send + 'static {
    /// The sender type for this network implementation.
    type Sender: Sender<PublicKey = ed25519::PublicKey> + Send;

    /// The receiver type for this network implementation.
    type Receiver: Receiver<PublicKey = ed25519::PublicKey> + Send;

    /// The oracle type for this network implementation.
    type Oracle: Blocker<PublicKey = ed25519::PublicKey> + Send;

    /// Creates and initializes a network instance for a single peer.
    ///
    /// # Parameters
    ///
    /// * `context` - The deterministic runtime context for this peer
    /// * `peer` - Information about the peer this network instance represents
    /// * `peers` - Information about all peers in the network (for discovery/bootstrapping)
    /// * `peer_idx` - The index of this peer in the peers array
    /// * `base_port` - The base port number used for peer addressing
    ///
    /// # Returns
    ///
    /// A network instance for interacting with the network.
    fn create_network<'a>(
        context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        peer_idx: usize,
        base_port: u16,
    ) -> impl Future<Output = Network<Self::Sender, Self::Receiver, Self::Oracle>>;

    /// Registers a subset of peers under a specific index with the oracle.
    ///
    /// This allows the network to track and communicate with specific peer groups.
    /// Different indices can have different peer subsets.
    ///
    /// # Parameters
    ///
    /// * `oracle` - The network oracle to register peers with
    /// * `index` - The index to register this peer subset under
    /// * `peers` - Information about all peers
    /// * `subset` - The public keys of the peers to register under this index
    fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) -> impl Future<Output = ()>;
}

/// Discovery network implementation for fuzzing.
pub struct Discovery;

impl NetworkScheme for Discovery {
    type Sender = discovery::Sender<ed25519::PublicKey>;
    type Receiver = discovery::Receiver<ed25519::PublicKey>;
    type Oracle = discovery::Oracle<ed25519::PublicKey>;

    async fn create_network<'a>(
        mut context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        peer_idx: usize,
        base_port: u16,
    ) -> Network<Self::Sender, Self::Receiver, Self::Oracle> {
        // Collect all peer public keys for potential discovery
        let addresses = peers
            .iter()
            .map(|p| p.public_key.clone())
            .collect::<Vec<_>>();

        // Set up bootstrappers: all peers except peer 0 bootstrap from peer 0
        let mut bootstrappers = Vec::new();
        if peer_idx > 0 {
            bootstrappers.push((
                addresses[0].clone(),
                SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), base_port),
            ));
        }

        // Create config with recommended defaults
        let mut config = discovery::Config::recommended(
            peer.private_key.clone(),
            b"fuzz_namespace",
            peer.address,
            peer.address,
            bootstrappers,
            MAX_MSG_SIZE,
        );
        // Override some settings for fuzzing environment
        config.mailbox_size = 100; // Small mailbox to encourage backpressure
        config.allow_private_ips = true; // Required for localhost testing
        config.tracked_peer_sets = PEER_SUBSET_NUMBER; // Track multiple peer subsets

        // Create the network and oracle for controlling it
        let (mut network, mut oracle) =
            discovery::Network::new(context.with_label("fuzzed-discovery-network"), config);

        // Pre-register some peer subsets to seed the network
        // Each index gets a randomized subset of 3 peers
        for index in 0..PEER_SUBSET_NUMBER {
            let mut addrs = addresses.clone();
            addrs.shuffle(&mut context);
            let subset = addrs[..3].to_vec();
            oracle.register(index as u64, subset).await;
        }

        let quota = Quota::per_second(NZU32!(100));
        let (sender, receiver) = network.register(0, quota, DEFAULT_MESSAGE_BACKLOG);

        // Start the network background task
        let handle = network.start();

        Network {
            sender,
            receiver,
            oracle,
            handle,
        }
    }

    async fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        _peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) {
        // Register the peer subset - for discovery, we only need public keys
        // since peers will discover addresses through the discovery protocol
        let _ = oracle.register(index, subset).await;
    }
}

/// Lookup network implementation for fuzzing.
pub struct Lookup;

impl NetworkScheme for Lookup {
    type Sender = lookup::Sender<ed25519::PublicKey>;
    type Receiver = lookup::Receiver<ed25519::PublicKey>;
    type Oracle = lookup::Oracle<ed25519::PublicKey>;

    async fn create_network<'a>(
        mut context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        _peer_idx: usize,
        _base_port: u16,
    ) -> Network<Self::Sender, Self::Receiver, Self::Oracle> {
        // Create lookup config - no bootstrappers needed since we register addresses directly
        let mut config = lookup::Config::recommended(
            peer.private_key.clone(),
            b"fuzz_namespace",
            peer.address,
            peer.address,
            MAX_MSG_SIZE,
        );
        config.allow_private_ips = true; // Required for localhost testing
        config.tracked_peer_sets = 2 * PEER_SUBSET_NUMBER;

        // Create the network and oracle
        let (mut network, mut oracle) =
            LookupNetwork::new(context.with_label("fuzzed-lookup-network"), config);

        // For lookup, we must provide both public keys AND addresses
        // (unlike discovery which finds addresses through the protocol)
        let peer_list: Vec<_> = peers
            .iter()
            .map(|p| (p.public_key.clone(), p.address))
            .collect();

        // Register multiple peer sets to seed the network
        // Register all peers for indices 0..PEER_SUBSET_NUMBER
        for index in 0..PEER_SUBSET_NUMBER {
            oracle.register(index as u64, peer_list.clone()).await;
        }

        // Register randomized subsets of 3 peers for indices PEER_SUBSET_NUMBER..2*PEER_SUBSET_NUMBER
        for index in PEER_SUBSET_NUMBER..(PEER_SUBSET_NUMBER * 2) {
            let mut peers = peer_list.clone();
            peers.shuffle(&mut context);
            let subset = peers[..3].to_vec();
            oracle.register(index as u64, subset).await;
        }

        let quota = Quota::per_second(NZU32!(100));
        let (sender, receiver) = network.register(0, quota, DEFAULT_MESSAGE_BACKLOG);

        // Start the network background task
        let handle = network.start();

        Network {
            sender,
            receiver,
            oracle,
            handle,
        }
    }

    async fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) {
        // For lookup, we need to map public keys to addresses
        // Filter out any keys that aren't in the peer list
        let peer_list: Vec<_> = subset
            .iter()
            .filter_map(|pk| {
                peers
                    .iter()
                    .find(|p| &p.public_key == pk)
                    .map(|p| (p.public_key.clone(), p.address))
            })
            .collect();
        let _ = oracle.register(index, peer_list).await;
    }
}

/// Main fuzzing entry point for testing p2p network implementations.
///
/// Creates a deterministic network of peers and executes a sequence of random operations
/// (sending messages, receiving messages, registering peer subsets, blocking peers).
///
/// # Type Parameters
///
/// * `N` - The network scheme to test ([Discovery] or [Lookup])
///
/// # Parameters
///
/// * `input` - The fuzz input containing the seed, number of peers, and operations to execute
///
/// # Behavior
///
/// 1. Creates N peers with deterministic keys and addresses
/// 2. Initializes a network instance for each peer
/// 3. Executes the sequence of operations from the fuzzer
/// 4. Tracks expected messages and verifies delivery
/// 5. Cleans up network handles when done
pub fn fuzz<N: NetworkScheme>(input: FuzzInput) {
    // Create a deterministic executor with the provided seed
    let executor = deterministic::Runner::seeded(input.seed);
    executor.start(|mut context| async move {
        let base_port = 63000;  // Arbitrary starting port for localhost testing
        
        // Build peer_infos and reverse lookup map together
        let mut pk_to_idx = HashMap::new();
        let mut peer_infos = Vec::new();

        for i in 0..input.peers {
            let private_key = ed25519::PrivateKey::from_seed(context.gen());
            let public_key = private_key.public_key();
            let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), base_port + i as u16);
            
            pk_to_idx.insert(public_key.clone(), i as u8);
            
            peer_infos.push(PeerInfo {
                private_key,
                public_key,
                address,
            });
        }

        // Create network instances and peer states
        let mut peers = Vec::new();

        for (peer_idx, peer_info) in peer_infos.iter().enumerate() {

            // Create network instance for this peer
            let peer_context = context.with_label(&format!("peer-{peer_idx}"));
            let network = N::create_network(
                peer_context,
                peer_info,
                &peer_infos,
                peer_idx,
                base_port,
            )
            .await;

            // Create and store peer state
            peers.push(Peer {
                info: PeerInfo {
                    private_key: peer_info.private_key.clone(),
                    public_key: peer_info.public_key.clone(),
                    address: peer_info.address,
                },
                network,
            });
        }

        // Execute fuzzer operations and track message expectations

        // Track expected messages: (to_idx, from_idx) -> queue of messages
        // Messages are sent with the same priority, ensuring FIFO delivery per sender-receiver pair
        let mut expected_msgs: HashMap<(u8, u8), VecDeque<Bytes>> = HashMap::new();

        // Peer index --> list of sender indices that have pending messages for this receiver
        let mut pending_by_receiver: HashMap<u8, Vec<u8>> = HashMap::new();

        for op in input.operations.into_iter() {
            match op {
                NetworkOperation::SendMessage {
                    sender_idx,
                    recipient_mode,
                    recipient_idx,
                    msg_size,
                } => {
                    // Normalize sender index to valid range
                    let from_idx = (sender_idx as usize) % peers.len();

                    // Clamp message size to not exceed max (accounting for channel overhead)
                    let msg_size = msg_size.clamp(0, MAX_MSG_SIZE - Channel::SIZE);

                    // Generate random message payload
                    let mut bytes = vec![0u8; msg_size];
                    context.fill(&mut bytes[..]);
                    let message = Bytes::from(bytes);

                    // Determine recipients based on the mode
                    let (recipients, _recipient_indices) = match recipient_mode {
                        RecipientMode::All => {
                            // Send to all peers except self
                            let indices: Vec<u8> = (0..peers.len())
                                .map(|i| i as u8)
                                .filter(|&to_idx| to_idx != from_idx as u8)
                                .collect();
                            (Recipients::All, indices)
                        }
                        RecipientMode::One => {
                            // Send to exactly one peer
                            let to_idx = (recipient_idx as usize) % peers.len();
                            if to_idx == from_idx {
                                continue;  // Skip if trying to send to self
                            }
                            let recipient_pk = peers[to_idx].info.public_key.clone();
                            (Recipients::One(recipient_pk), vec![to_idx as u8])
                        }
                        RecipientMode::Some => {
                            // Send to a random subset of peers
                            let mut available: Vec<_> = (0..peers.len())
                                .filter(|&i| i != from_idx)  // Exclude sender
                                .collect();

                            if available.is_empty() {
                                continue;  // Only 1 peer (self) in network, can't send anywhere
                            }

                            // Randomly select some subset of peers
                            available.shuffle(&mut context);
                            let num_recipients = context.gen_range(1..=available.len());
                            let selected = &available[..num_recipients];

                            let recipients_set: HashSet<_> = selected.iter()
                                .map(|&idx| peers[idx].info.public_key.clone())
                                .collect();
                            let indices: Vec<_> = selected.iter().map(|&idx| idx as u8).collect();
                            (Recipients::Some(recipients_set.into_iter().collect()), indices)
                        }
                    };

                    // Attempt to send the message (always use low priority for FIFO ordering)
                    let send_result = peers[from_idx]
                        .network
                        .sender
                        .send(recipients, message.clone(), false)
                        .await;

                    // Only enqueue expectations for recipients that actually accepted the payload
                    if let Ok(accepted_recipients) = send_result {
                        // Map accepted recipient public keys to indices
                        for pk in accepted_recipients.into_iter() {
                            if let Some(&to_idx) = pk_to_idx.get(&pk) {
                                // Add message to the queue for this (receiver, sender) pair
                                expected_msgs
                                    .entry((to_idx, from_idx as u8))
                                    .or_default()
                                    .push_back(message.clone());

                                // Track that this receiver has pending messages from this sender
                                let senders = pending_by_receiver.entry(to_idx).or_default();
                                if !senders.contains(&(from_idx as u8)) {
                                    senders.push(from_idx as u8);
                                }
                            }
                        }
                    }
                }

                NetworkOperation::ReceiveMessages => {
                    // Attempt to receive one message from each receiver with pending messages
                    // Strategy: For each receiver, try to receive from ANY sender, then verify
                    // the message matches expectations for that specific sender
                    let receivers_with_pending: Vec<u8> = pending_by_receiver.keys().cloned().collect();

                    for to_idx in receivers_with_pending {
                        // Safety check: ensure receiver index is valid
                        if to_idx as usize >= peers.len() {
                            continue;
                        }

                        let receiver = &mut peers[to_idx as usize].network.receiver;

                        // Try to receive one message with a timeout
                        commonware_macros::select! {
                            result = receiver.recv() => {
                                let Ok((sender_pk, message)) = result else {
                                    continue; // Receive error (not timeout)
                                };

                                // Identify the sender by their public key
                                let Some(&from_idx) = pk_to_idx.get(&sender_pk) else {
                                    panic!("Received message from unknown sender: {}", sender_pk);
                                };

                                // Check if we expected a message from this sender to this receiver
                                let expected_msgs_key = (to_idx, from_idx);
                                if let Some(queue) = expected_msgs.get_mut(&expected_msgs_key) {
                                    // Verify message is at front of queue (FIFO ordering per sender-receiver pair)
                                    if queue.front() == Some(&message) {
                                        queue.pop_front();

                                        // Clean up empty queues
                                        if queue.is_empty() {
                                            expected_msgs.remove(&expected_msgs_key);
                                        }

                                        // Update pending tracking
                                        if let Some(senders) = pending_by_receiver.get_mut(&to_idx) {
                                            if let Some(pos) = senders.iter().position(|&x| x == from_idx) {
                                                senders.remove(pos);
                                            }
                                            if senders.is_empty() {
                                                pending_by_receiver.remove(&to_idx);
                                            }
                                        }
                                    } else {
                                        panic!(
                                            "Message out of order from sender {} to receiver {}. Expected: {:?}, Got: {:?}",
                                            from_idx, to_idx,
                                            queue.front().map(|b| b.len()),
                                            message.len()
                                        );
                                    }
                                } else {
                                    // No expectations for this sender-receiver pair
                                    // This can happen if the sender was blocked after sending but before delivery
                                    continue;
                                }
                            },
                            _ = context.sleep(Duration::from_millis(MAX_SLEEP_DURATION)) => {
                                // Timeout: message didn't arrive in time, continue to next receiver
                                continue;
                            },
                        }
                    }
                }

                NetworkOperation::RegisterPeers {
                    peer_idx,
                    index,
                    num_peers,
                } => {
                    // Register a subset of peers under the given index
                    // Normalize parameters to valid ranges
                    let peer_idx = (peer_idx as usize) % peers.len();
                    let index = index % MAX_INDEX;
                    let num_peers = (num_peers as usize).clamp(1, peers.len());

                    // Build a random subset of peers (using a set to avoid duplicates)
                    let mut peer_set = HashSet::new();
                    for _ in 0..num_peers {
                        let idx = context.gen::<usize>() % peers.len();
                        peer_set.insert(peers[idx].info.public_key.clone());
                    }
                    let peer_subset: Vec<_> = peer_set.into_iter().collect();

                    // Register this subset with the oracle
                    N::register_peers(
                        &mut peers[peer_idx].network.oracle,
                        index as u64,
                        &peer_infos,
                        peer_subset,
                    )
                    .await;
                }

                NetworkOperation::BlockPeer { peer_idx, target_idx } => {
                    // Block a peer from sending messages to another peer
                    // Normalize indices to valid ranges
                    let to_idx = (peer_idx as usize) % peers.len();
                    let from_idx = (target_idx as usize) % peers.len();

                    // Block the target peer on the oracle
                    let target_pk = peers[from_idx].info.public_key.clone();
                    let _ = peers[to_idx].network.oracle.block(target_pk).await;

                    // Update our tracking: remove any expectations for messages
                    // from the blocked peer to this peer
                    expected_msgs.retain(|(receiver, sender), _queue| {
                        !(*receiver == to_idx as u8 && *sender == from_idx as u8)
                    });

                    // Clean up pending tracking for the blocked sender
                    if let Some(senders) = pending_by_receiver.get_mut(&(to_idx as u8)) {
                        senders.retain(|&sender| sender != from_idx as u8);
                        if senders.is_empty() {
                            pending_by_receiver.remove(&(to_idx as u8));
                        }
                    }
                }
            }
        }

        // Clean up network handles before exiting
        for peer in peers {
            peer.network.handle.abort();
        }
    });
}
