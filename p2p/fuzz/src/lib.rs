use arbitrary::Arbitrary;
use bytes::Bytes;
use commonware_codec::codec::FixedSize;
use commonware_cryptography::{ed25519, PrivateKeyExt, Signer};
use commonware_p2p::{
    authenticated::{
        discovery,
        lookup::{self, Network as LookupNetwork},
    },
    Blocker, Channel, Receiver, Recipients, Sender,
};
use commonware_runtime::{deterministic, deterministic::Context, Clock, Handle, Metrics, Runner};
use commonware_utils::NZU32;
use governor::Quota;
use rand::{seq::SliceRandom, Rng};
use std::{
    collections::{HashMap, HashSet, VecDeque},
    future::Future,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    time::Duration,
};

const MAX_OPERATIONS: usize = 30;
const MAX_PEERS: usize = 8;
const MIN_PEERS: usize = 4;
const MAX_MSG_SIZE: usize = 1024 * 1024;
const MAX_INDEX: u8 = 10;
const PEER_SUBSET_NUMBER: usize = 5;
const DEFAULT_MESSAGE_BACKLOG: usize = 128;
const MAX_SLEEP_DURATION: u64 = 1000;

/// Modes for selecting message recipients during fuzzing.
#[derive(Debug, Arbitrary)]
pub enum RecipientMode {
    /// Send to all peers except the sender.
    All,
    /// Send to exactly one peer.
    One,
    /// Send to a random subset of peers.
    Some,
}

/// Operations that can be performed on the p2p network during fuzzing.
#[derive(Debug, Arbitrary)]
pub enum NetworkOperation {
    /// Send a message from one peer to one or more recipients.
    SendMessage {
        /// Index of the peer sending the message.
        sender_idx: u8,
        /// How to select recipients.
        recipient_mode: RecipientMode,
        /// Index of the recipient peer (used for `RecipientMode::One`).
        recipient_idx: u8,
        /// Size of the message payload in bytes.
        msg_size: usize,
        /// Whether to send with priority.
        priority: bool,
    },
    /// Attempt to receive messages from any peers with pending messages.
    ReceiveMessages,
    /// Register a subset of peers under a specific index.
    RegisterPeers {
        /// Index of the peer whose oracle will register the subset.
        peer_idx: u8,
        /// The index to register the peer subset under.
        index: u8,
        /// Number of peers to include in the subset.
        num_peers: u8,
    },
    /// Block a target peer from sending messages to the blocking peer.
    BlockPeer {
        /// Index of the peer that will block the target.
        peer_idx: u8,
        /// Index of the peer to be blocked.
        target_idx: u8,
    },
}

/// Input generated by the fuzzer for testing p2p networks.
#[derive(Debug)]
pub struct FuzzInput {
    /// Random seed for deterministic execution.
    pub seed: u64,
    /// Sequence of operations to execute on the network.
    ///
    /// Length is in the range [1, MAX_OPERATIONS].
    pub operations: Vec<NetworkOperation>,
    /// Number of peers to create in the network.
    ///
    /// Must be in the range [MIN_PEERS, MAX_PEERS].
    pub peers: u8,
}

impl<'a> Arbitrary<'a> for FuzzInput {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let seed = u.arbitrary()?;
        let num_operations = u.int_in_range(1..=MAX_OPERATIONS)?;
        let mut operations = Vec::with_capacity(num_operations);
        for _ in 0..num_operations {
            operations.push(u.arbitrary()?);
        }
        let peers = u.int_in_range(MIN_PEERS..=MAX_PEERS)? as u8;
        Ok(FuzzInput {
            seed,
            operations,
            peers,
        })
    }
}

/// Information about a peer in the network.
pub struct PeerInfo {
    /// The peer's private key.
    pub private_key: ed25519::PrivateKey,
    /// The peer's public key .
    pub public_key: ed25519::PublicKey,
    /// The network address where this peer can be reached.
    pub address: SocketAddr,
}

/// Components returned when creating a network instance.
///
/// Contains everything needed to interact with the network:
/// - `S`: Sender for sending messages to other peers
/// - `R`: Receiver for receiving messages from other peers
/// - `O`: Oracle for controlling the network (registering peers, blocking, etc.)
/// - `Handle<()>`: Handle to the running network task that can be aborted
pub type NetworkComponents<S, R, O> = (S, R, O, Handle<()>);

/// Trait for abstracting over different p2p network implementations (Discovery, Lookup) during fuzzing.
///
/// This allows the same fuzzing logic to test multiple network implementations by providing
/// a common interface for network creation and peer registration.
pub trait NetworkScheme: Send + 'static {
    /// The sender type for this network implementation.
    type Sender: Sender<PublicKey = ed25519::PublicKey> + Send;

    /// The receiver type for this network implementation.
    type Receiver: Receiver<PublicKey = ed25519::PublicKey> + Send;

    /// The oracle type for this network implementation.
    type Oracle: Blocker<PublicKey = ed25519::PublicKey> + Send;

    /// Creates and initializes a network instance for a single peer.
    ///
    /// # Parameters
    ///
    /// * `context` - The deterministic runtime context for this peer
    /// * `peer` - Information about the peer this network instance represents
    /// * `peers` - Information about all peers in the network (for discovery/bootstrapping)
    /// * `peer_idx` - The index of this peer in the peers array
    /// * `base_port` - The base port number used for peer addressing
    ///
    /// # Returns
    ///
    /// A tuple containing:
    /// - The sender for sending messages
    /// - The receiver for receiving messages
    /// - The oracle for controlling the network
    /// - A handle to the running network task
    fn create_network<'a>(
        context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        peer_idx: usize,
        base_port: u16,
    ) -> impl Future<Output = NetworkComponents<Self::Sender, Self::Receiver, Self::Oracle>>;

    /// Registers a subset of peers under a specific index with the oracle.
    ///
    /// This allows the network to track and communicate with specific peer groups.
    /// Different indices can have different peer subsets.
    ///
    /// # Parameters
    ///
    /// * `oracle` - The network oracle to register peers with
    /// * `index` - The index to register this peer subset under
    /// * `peers` - Information about all peers
    /// * `subset` - The public keys of the peers to register under this index
    fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) -> impl Future<Output = ()>;
}

/// Discovery network implementation for fuzzing.
pub struct Discovery;

impl NetworkScheme for Discovery {
    type Sender = discovery::Sender<ed25519::PublicKey>;
    type Receiver = discovery::Receiver<ed25519::PublicKey>;
    type Oracle = discovery::Oracle<ed25519::PublicKey>;

    async fn create_network<'a>(
        mut context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        peer_idx: usize,
        base_port: u16,
    ) -> NetworkComponents<Self::Sender, Self::Receiver, Self::Oracle> {
        // Collect all peer public keys for potential discovery
        let addresses = peers
            .iter()
            .map(|p| p.public_key.clone())
            .collect::<Vec<_>>();

        // Set up bootstrappers: all peers except peer 0 bootstrap from peer 0
        let mut bootstrappers = Vec::new();
        if peer_idx > 0 {
            bootstrappers.push((
                addresses[0].clone(),
                SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), base_port),
            ));
        }

        // Create config with recommended defaults
        let mut config = discovery::Config::recommended(
            peer.private_key.clone(),
            b"fuzz_namespace",
            peer.address,
            peer.address,
            bootstrappers,
            MAX_MSG_SIZE,
        );
        // Override some settings for fuzzing environment
        config.mailbox_size = 100; // Small mailbox to encourage backpressure
        config.allow_private_ips = true; // Required for localhost testing
        config.tracked_peer_sets = PEER_SUBSET_NUMBER; // Track multiple peer subsets

        // Create the network and oracle for controlling it
        let (mut network, mut oracle) =
            discovery::Network::new(context.with_label("fuzzed-discovery-network"), config);

        // Pre-register some peer subsets to seed the network
        // Each index gets a randomized subset of 3 peers
        for index in 0..PEER_SUBSET_NUMBER {
            let mut addrs = addresses.clone();
            addrs.shuffle(&mut context);
            let subset = addrs[..3].to_vec();
            oracle.register(index as u64, subset).await;
        }

        let quota = Quota::per_second(NZU32!(100));
        let (sender, receiver) = network.register(0, quota, DEFAULT_MESSAGE_BACKLOG);

        // Start the network background task
        let handle = network.start();

        (sender, receiver, oracle, handle)
    }

    async fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        _peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) {
        // Register the peer subset - for discovery, we only need public keys
        // since peers will discover addresses through the discovery protocol
        let _ = oracle.register(index, subset).await;
    }
}

/// Lookup network implementation for fuzzing.
pub struct Lookup;

impl NetworkScheme for Lookup {
    type Sender = lookup::Sender<ed25519::PublicKey>;
    type Receiver = lookup::Receiver<ed25519::PublicKey>;
    type Oracle = lookup::Oracle<ed25519::PublicKey>;

    async fn create_network<'a>(
        mut context: Context,
        peer: &'a PeerInfo,
        peers: &'a [PeerInfo],
        _peer_idx: usize,
        _base_port: u16,
    ) -> NetworkComponents<Self::Sender, Self::Receiver, Self::Oracle> {
        // Create lookup config - no bootstrappers needed since we register addresses directly
        let mut config = lookup::Config::recommended(
            peer.private_key.clone(),
            b"fuzz_namespace",
            peer.address,
            peer.address,
            MAX_MSG_SIZE,
        );
        config.allow_private_ips = true; // Required for localhost testing
        config.tracked_peer_sets = 2 * PEER_SUBSET_NUMBER;

        // Create the network and oracle
        let (mut network, mut oracle) =
            LookupNetwork::new(context.with_label("fuzzed-lookup-network"), config);

        // For lookup, we must provide both public keys AND addresses
        // (unlike discovery which finds addresses through the protocol)
        let peer_list: Vec<_> = peers
            .iter()
            .map(|p| (p.public_key.clone(), p.address))
            .collect();

        // Register multiple peer sets to seed the network
        // Register all peers for indices 0..PEER_SUBSET_NUMBER
        for index in 0..PEER_SUBSET_NUMBER {
            oracle.register(index as u64, peer_list.clone()).await;
        }

        // Register randomized subsets of 3 peers for indices PEER_SUBSET_NUMBER..2*PEER_SUBSET_NUMBER
        for index in PEER_SUBSET_NUMBER..(PEER_SUBSET_NUMBER * 2) {
            let mut peers = peer_list.clone();
            peers.shuffle(&mut context);
            let subset = peers[..3].to_vec();
            oracle.register(index as u64, subset).await;
        }

        let quota = Quota::per_second(NZU32!(100));
        let (sender, receiver) = network.register(0, quota, DEFAULT_MESSAGE_BACKLOG);

        // Start the network background task
        let handle = network.start();

        (sender, receiver, oracle, handle)
    }

    async fn register_peers<'a>(
        oracle: &'a mut Self::Oracle,
        index: u64,
        peers: &'a [PeerInfo],
        subset: Vec<ed25519::PublicKey>,
    ) {
        // For lookup, we need to map public keys to addresses
        // Filter out any keys that aren't in the peer list
        let peer_list: Vec<_> = subset
            .iter()
            .filter_map(|pk| {
                peers
                    .iter()
                    .find(|p| &p.public_key == pk)
                    .map(|p| (p.public_key.clone(), p.address))
            })
            .collect();
        let _ = oracle.register(index, peer_list).await;
    }
}

/// Main fuzzing entry point for testing p2p network implementations.
///
/// Creates a deterministic network of peers and executes a sequence of random operations
/// (sending messages, receiving messages, registering peer subsets, blocking peers).
///
/// # Type Parameters
///
/// * `N` - The network scheme to test ([Discovery] or [Lookup])
///
/// # Parameters
///
/// * `input` - The fuzz input containing the seed, number of peers, and operations to execute
///
/// # Behavior
///
/// 1. Creates N peers with deterministic keys and addresses
/// 2. Initializes a network instance for each peer
/// 3. Executes the sequence of operations from the fuzzer
/// 4. Tracks expected messages and verifies delivery
/// 5. Cleans up network handles when done
pub fn fuzz<N: NetworkScheme>(input: FuzzInput) {
    // Create a deterministic executor with the provided seed
    let executor = deterministic::Runner::seeded(input.seed);
    executor.start(|mut context| async move {
        // Generate peer identities and addresses
        let mut peers = Vec::new();
        let base_port = 63000;  // Arbitrary starting port for localhost testing

        // Create N peers with deterministic keys
        for i in 0..input.peers {
            let private_key = ed25519::PrivateKey::from_seed(context.gen());
            let public_key = private_key.public_key();
            let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), base_port + i as u16);
            peers.push(PeerInfo {
                private_key,
                public_key,
                address,
            });
        }

        // Build a reverse lookup: public key -> peer index
        // Used to identify senders when receiving messages
        let pk_to_idx: HashMap<ed25519::PublicKey, u8> = peers
            .iter()
            .enumerate()
            .map(|(idx, peer)| (peer.public_key.clone(), idx as u8))
            .collect();

        // Initialize network instances for each peer
        let mut networks = Vec::new();
        let mut oracles = Vec::new();

        for (peer_idx, peer) in peers.iter().enumerate() {
            let context = context.with_label(&format!("peer-{peer_idx}"));

            // Create a network instance for this peer
            let (sender, receiver, oracle, handle) = N::create_network(
                context.clone(),
                peer,
                &peers,
                peer_idx,
                base_port,
            )
            .await;

            // Store sender/receiver/handle for message operations
            networks.push((sender, receiver, Some(handle)));
            // Store oracle separately for control operations
            oracles.push(oracle);
        }

        // Execute fuzzer operations and track message expectations

        // Track expected messages: (receiver_idx, sender_idx) -> queue of messages
        // We verify that every sent message is eventually received in order per sender-receiver pair
        let mut expected_messages: HashMap<(u8, u8), VecDeque<Bytes>> = HashMap::new();

        // Track which receivers have pending messages from which senders
        // This optimizes the ReceiveMessages operation to only check receivers with pending messages
        let mut pending_by_receiver: HashMap<u8, Vec<u8>> = HashMap::new();

        for op in input.operations.into_iter() {
            match op {
                NetworkOperation::SendMessage {
                    sender_idx,
                    recipient_mode,
                    recipient_idx,
                    msg_size,
                    priority,
                } => {
                    // Normalize sender index to valid peer range
                    let sender_idx = (sender_idx as usize) % peers.len();
                    let sender_idx_u8 = sender_idx as u8;

                    // Clamp message size to not exceed max (accounting for channel overhead)
                    let msg_size = msg_size.clamp(0, MAX_MSG_SIZE - Channel::SIZE);

                    // Generate a random message payload
                    let mut bytes = vec![0u8; msg_size];
                    context.fill(&mut bytes[..]);
                    let message = Bytes::from(bytes);

                    // Determine recipients based on the mode
                    let (recipients, recipients_indices) = match recipient_mode {
                        RecipientMode::All => {
                            // Send to all peers except self
                            let indices: Vec<u8> = (0..peers.len())
                                .map(|i| i as u8)
                                .filter(|&to_idx| to_idx != sender_idx_u8)
                                .collect();
                            (Recipients::All, indices)
                        }
                        RecipientMode::One => {
                            // Send to exactly one peer
                            let idx = (recipient_idx as usize) % peers.len();
                            if idx == sender_idx {
                                continue;  // Skip if trying to send to self
                            }
                            let recipient_pk = peers[idx].public_key.clone();
                            (Recipients::One(recipient_pk), vec![idx as u8])
                        }
                        RecipientMode::Some => {
                            // Send to a random subset of peers
                            let mut available: Vec<_> = (0..peers.len())
                                .filter(|&i| i != sender_idx)  // Exclude sender
                                .collect();

                            if available.is_empty() {
                                continue;  // Only 1 peer (self) in network, can't send anywhere
                            }

                            // Randomly select some subset of peers
                            available.shuffle(&mut context);
                            let num_recipients = context.gen_range(1..=available.len());
                            let selected = &available[..num_recipients];

                            let recipients_set: HashSet<_> = selected.iter()
                                .map(|&idx| peers[idx].public_key.clone())
                                .collect();
                            let indices: Vec<_> = selected.iter().map(|&idx| idx as u8).collect();
                            (Recipients::Some(recipients_set.into_iter().collect()), indices)
                        }
                    };

                    // Attempt to send the message
                    let sent = networks[sender_idx]
                        .0
                        .send(recipients, message.clone(), priority)
                        .await
                        .is_ok();

                    // If send succeeded, track the message as expected for each recipient
                    if sent {
                        for to_idx in recipients_indices {
                            // Add message to the queue for this (receiver, sender) pair
                            expected_messages
                                .entry((to_idx, sender_idx_u8))
                                .or_default()
                                .push_back(message.clone());

                            // Track that this receiver has pending messages from this sender
                            pending_by_receiver
                                .entry(to_idx)
                                .or_default()
                                .push(sender_idx_u8);
                        }
                    }
                }

                NetworkOperation::ReceiveMessages => {
                    // Attempt to receive messages from all peers that have pending messages
                    // We iterate through all receivers that we expect to have messages
                    let receivers_with_pending: Vec<u8> = pending_by_receiver.keys().cloned().collect();

                    for receiver_idx_u8 in receivers_with_pending {
                        let receiver_idx = receiver_idx_u8 as usize;

                        // Safety check: ensure receiver index is valid
                        if receiver_idx >= networks.len() {
                            continue;
                        }

                        // Re-check if this receiver still has pending messages
                        // (may have been cleared by a previous iteration)
                        // TODO danlaine: check this
                        if !pending_by_receiver.contains_key(&receiver_idx_u8) {
                            continue;
                        }

                        let receiver = &mut networks[receiver_idx].1;

                        // TODO danlaine: check this select
                        // Try to receive one message with a timeout
                        commonware_macros::select! {
                            result = receiver.recv() => {
                                // Skip if receive failed TODO danlaine: check this
                                let Ok((sender_pk, message)) = result else {
                                    continue;
                                };

                                // Identify the sender by their public key
                                let Some(&actual_sender_idx) = pk_to_idx.get(&sender_pk) else {
                                    continue;  // Unknown sender, shouldn't happen. TODO danlaine: check this
                                };

                                // Check if we expected a message from this sender to this receiver
                                let key = (receiver_idx_u8, actual_sender_idx);
                                if let Some(queue) = expected_messages.get_mut(&key) {
                                    // Search for this message in the expected queue
                                    // NOTE: Messages may arrive out of order, so we search the entire queue
                                    let mut found_index = None;
                                    for (i, expected) in queue.iter().enumerate() {
                                        if message == *expected {
                                            found_index = Some(i);
                                            break;
                                        }
                                    }

                                    if let Some(index) = found_index {
                                        // Message was expected. Remove it from the queue
                                        queue.remove(index);

                                        // Clean up empty queues
                                        if queue.is_empty() {
                                            expected_messages.remove(&key);
                                        }

                                        // Update pending tracking
                                        if let Some(senders) = pending_by_receiver.get_mut(&receiver_idx_u8) {
                                            if let Some(pos) = senders.iter().position(|&x| x == actual_sender_idx) {
                                                senders.remove(pos);
                                            }
                                            if senders.is_empty() {
                                                pending_by_receiver.remove(&receiver_idx_u8);
                                            }
                                        }
                                    } else {
                                        // Received a message we didn't expect (or received duplicate)
                                        panic!("Peer index {} Received unexpected message from sender {}", receiver_idx_u8, actual_sender_idx);
                                    }
                                } else {
                                    // Received a message from a sender-receiver pair we never tracked
                                    panic!("Unexpected delivery for peer {} with index {}", peers[receiver_idx_u8 as usize].public_key, receiver_idx_u8);
                                }
                            },
                            _ = context.sleep(Duration::from_millis(MAX_SLEEP_DURATION)) => {
                                // Timeout: message didn't arrive in time, continue to next receiver
                                continue;
                            },
                        }
                    }
                }

                NetworkOperation::RegisterPeers {
                    peer_idx,
                    index,
                    num_peers,
                } => {
                    // Register a subset of peers under the given index
                    // Normalize parameters to valid ranges
                    let peer_idx = (peer_idx as usize) % peers.len();
                    let index = index % MAX_INDEX;
                    let num_peers = (num_peers as usize).clamp(1, peers.len());

                    // Build a random subset of peers (using a set to avoid duplicates)
                    let mut peer_set = HashSet::new();
                    for _ in 0..num_peers {
                        let idx = context.gen::<usize>() % peers.len();
                        peer_set.insert(peers[idx].public_key.clone());
                    }
                    let peer_subset: Vec<_> = peer_set.into_iter().collect();

                    // Register this subset with the oracle
                    N::register_peers(
                        &mut oracles[peer_idx],
                        index as u64,
                        &peers,
                        peer_subset,
                    )
                    .await;
                }

                NetworkOperation::BlockPeer { peer_idx, target_idx } => {
                    // Block a peer from sending messages to another peer
                    // Normalize indices to valid ranges
                    let peer_idx = (peer_idx as usize) % peers.len();
                    let peer_idx_u8 = peer_idx as u8;
                    let target_idx = (target_idx as usize) % peers.len();
                    let target_idx_u8 = target_idx as u8;

                    // Block the target peer on the oracle
                    let target_pk = peers[target_idx].public_key.clone();
                    let _ = oracles[peer_idx].block(target_pk).await;

                    // Update our tracking: remove any expectations for messages
                    // from the blocked peer to this peer
                    expected_messages.retain(|(to_idx, from_idx), _queue| {
                        !(*to_idx == peer_idx_u8 && *from_idx == target_idx_u8)
                    });

                    // Clean up pending tracking for the blocked sender
                    if let Some(senders) = pending_by_receiver.get_mut(&peer_idx_u8) {
                        senders.retain(|&from_idx| from_idx != target_idx_u8);
                        if senders.is_empty() {
                            pending_by_receiver.remove(&peer_idx_u8);
                        }
                    }
                }
            }
        }

        // Clean up network handles before exiting
        for (_, _, handle) in networks {
            if let Some(h) = handle {
                h.abort();
            }
        }
    });
}
