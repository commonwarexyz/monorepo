#!/usr/bin/env python3
"""Generate src/test_registry.rs from tools/message_counts.json.

This script reads the message counts JSON and generates a Rust file containing
a static array of all fuzzable tests with their metadata.

Usage:
    python3 scripts/gen_test_registry.py                    # Generate from all tests
    python3 scripts/gen_test_registry.py --tests tests.txt  # Use pre-filtered test list
"""

import argparse
import json
import sys
from pathlib import Path


def test_to_import_and_ref(test_name: str) -> tuple[str, str, str]:
    """Convert test name to (import_statement, alias, function_ref).

    Example:
        'commonware-broadcast::buffered::tests::test_packet_loss'
        -> ('use commonware_broadcast::buffered::tests as broadcast_buffered_tests;',
            'broadcast_buffered_tests',
            'broadcast_buffered_tests::test_packet_loss')
    """
    parts = test_name.split("::")
    crate = parts[0].replace("-", "_")
    test_fn = parts[-1]

    # Handle binary crate test paths like "commonware-reshare::bin/commonware-reshare::validator::test::..."
    # nextest adds "bin/crate-name::" for binary crates
    if len(parts) > 1 and parts[1].startswith("bin/"):
        # Skip the "bin/crate-name" part
        parts = [parts[0]] + parts[2:]

    # Build module path - handle both "tests" and "test" module names
    test_mod_name = parts[-2]  # Could be "tests" or "test"
    if test_mod_name in ("tests", "test"):
        module_parts = parts[1:-2]
    else:
        module_parts = parts[1:-1]
        test_mod_name = "tests"  # Default assumption

    module_path = "::".join(module_parts) if module_parts else ""

    # Create import and alias
    if module_path:
        mod_path = f"{module_path}::{test_mod_name}"
        alias = f"{crate.replace('commonware_', '')}_{module_path.replace('::', '_')}_{test_mod_name}"
    else:
        mod_path = test_mod_name
        alias = f"{crate.replace('commonware_', '')}_{test_mod_name}"

    import_stmt = f"use {crate}::{mod_path} as {alias};"
    fn_ref = f"{alias}::{test_fn}"

    return import_stmt, alias, fn_ref


def generate_registry(tests: list, skipped: list, output: Path) -> None:
    """Generate src/test_registry.rs from test list."""
    imports = set()
    entries = []

    for idx, (test_name, msg_count, duration) in enumerate(tests):
        import_stmt, alias, fn_ref = test_to_import_and_ref(test_name)
        imports.add(import_stmt)

        # Duration in milliseconds
        duration_ms = int(duration * 1000)

        # Format duration for comment
        if duration < 1.0:
            duration_str = f"{duration_ms}ms"
        else:
            duration_str = f"{duration:.1f}s"

        entries.append(f'    TestEntry::new("{fn_ref}", {msg_count}, {duration_ms}, {fn_ref}), // {idx}: {duration_str}')

    # Build skipped tests comment section
    skipped_section = ""
    if skipped:
        skipped_section = "\n// Skipped tests:\n"
        for test_name, reason in skipped:
            skipped_section += f"// - {test_name}: {reason}\n"

    content = f"""// @generated
// This file is auto-generated by scripts/gen_test_registry.py - DO NOT EDIT.
//! Centralized test registry for fuzzing harnesses
//!
//! This module provides a single source of truth for all fuzzable tests,
//! eliminating duplication between LibFuzzer and AFL++ harnesses.
//!
//! Requires the `test-registry` feature to be enabled.

{chr(10).join(sorted(imports))}

/// A single fuzzable test with its metadata
#[derive(Clone, Copy)]
pub struct TestEntry {{
    pub name: &'static str,
    pub message_count: usize,
    pub duration_ms: u32,
    pub test_fn: fn(),
}}

impl TestEntry {{
    pub const fn new(name: &'static str, message_count: usize, duration_ms: u32, test_fn: fn()) -> Self {{
        Self {{ name, message_count, duration_ms, test_fn }}
    }}
}}

/// Number of tests in the registry
pub const NUM_TESTS: usize = {len(tests)};

/// All fuzzable tests sorted by duration (fastest first).
///
/// This is the canonical list - all harnesses should use this.
/// Generated from tools/message_counts.json
pub static TESTS: [TestEntry; NUM_TESTS] = [
{chr(10).join(entries)}
];

/// Get test entry by index
#[inline]
pub fn get_test(index: usize) -> Option<&'static TestEntry> {{
    TESTS.get(index)
}}

/// Get test entry by name (e.g., "consensus_simplex_tests::test_all_online")
#[inline]
pub fn get_test_by_name(name: &str) -> Option<&'static TestEntry> {{
    TESTS.iter().find(|e| e.name == name)
}}
{skipped_section}"""

    output.write_text(content)


def main():
    parser = argparse.ArgumentParser(description="Generate test registry from message_counts.json")
    parser.add_argument("--tests", type=Path, help="File with pre-filtered test list (one per line: test_name,msg_count,duration)")
    parser.add_argument("--skipped", type=Path, help="File with skipped tests (one per line: test_name,reason)")
    parser.add_argument("-n", type=int, help="Limit to top N tests (by duration)")
    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    msg_counts = repo_root / "tools" / "message_counts.json"
    registry_path = repo_root / "src" / "test_registry.rs"

    if args.tests:
        # Read from pre-filtered test list
        tests = []
        with open(args.tests) as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                parts = line.split(",")
                tests.append((parts[0], int(parts[1]), float(parts[2])))
        skipped = []
        if args.skipped and args.skipped.exists():
            with open(args.skipped) as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    parts = line.split(",", 1)
                    skipped.append((parts[0], parts[1] if len(parts) > 1 else "unknown"))
    else:
        # Read from message_counts.json
        if not msg_counts.exists():
            print(f"Error: {msg_counts} not found")
            sys.exit(1)

        with open(msg_counts) as f:
            tests = []
            for line in f:
                data = json.loads(line)
                if "test" in data:
                    tests.append((data["test"], data["messages"], data["duration_secs"]))

        # Sort by duration (fast tests first)
        tests.sort(key=lambda x: x[2])

        # Limit if requested
        if args.n:
            tests = tests[:args.n]

        skipped = []  # No skipped info when reading directly from JSON

    generate_registry(tests, skipped, registry_path)
    print(f"Generated {registry_path.relative_to(repo_root)} with {len(tests)} tests")


if __name__ == "__main__":
    main()
