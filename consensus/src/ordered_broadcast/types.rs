use super::Error;
use bytes::{Buf, BufMut};
use commonware_codec::{EncodeSize, Error as CodecError, FixedSize, Read, Write};
use commonware_cryptography::{
    bls12381::primitives::{
        group::{Public, Signature},
        ops,
        poly::PartialSignature,
    },
    Digest, Verifier,
};
use commonware_utils::{union, Array};

/// Used as the [`Index`](crate::Supervisor::Index) type.
/// Defines the current set of sequencers and validators.
///
/// This is not a single "View" in the sense of a consensus protocol, but rather a continuous
/// sequence of views in-which the set of sequencers and validators is constant.
pub type Epoch = u64;

/// Used as the [`Automaton::Context`](crate::Automaton::Context) type.
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct Context<P: Array> {
    /// Sequencer's public key.
    pub sequencer: P,

    /// Sequencer-specific sequential height. Zero-indexed.
    pub height: u64,
}

const CHUNK_SUFFIX: &[u8] = b"_CHUNK";
const ACK_SUFFIX: &[u8] = b"_ACK";

/// Returns a suffixed namespace for signing a chunk.
pub fn chunk_namespace(namespace: &[u8]) -> Vec<u8> {
    union(namespace, CHUNK_SUFFIX)
}

/// Returns a suffixed namespace for signing an ack.
pub fn ack_namespace(namespace: &[u8]) -> Vec<u8> {
    union(namespace, ACK_SUFFIX)
}

/// Wire are messages that are sent over the network.
#[derive(Clone, Debug, PartialEq)]
pub enum Wire<C: Verifier, D: Digest> {
    Node(Node<C, D>),
    Ack(Ack<C::PublicKey, D>),
}

impl<C: Verifier, D: Digest> Write for Wire<C, D> {
    fn write(&self, writer: &mut impl BufMut) {
        match self {
            Wire::Node(node) => {
                0u8.write(writer);
                node.write(writer);
            }
            Wire::Ack(ack) => {
                1u8.write(writer);
                ack.write(writer);
            }
        }
    }
}

impl<C: Verifier, D: Digest> EncodeSize for Wire<C, D> {
    fn encode_size(&self) -> usize {
        1 + match self {
            Wire::Node(node) => node.encode_size(),
            Wire::Ack(ack) => ack.encode_size(),
        }
    }
}

impl<C: Verifier, D: Digest> Read for Wire<C, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        match u8::read(reader)? {
            0 => Ok(Wire::Node(Node::read(reader)?)),
            1 => Ok(Wire::Ack(Ack::read(reader)?)),
            _ => Err(CodecError::Invalid(
                "consensus::ordered_broadcast::Wire",
                "Invalid type",
            )),
        }
    }
}

/// Chunk is a message generated by a sequencer that is broadcasted to all validators.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Chunk<P: Array, D: Digest> {
    /// Sequencer's public key.
    pub sequencer: P,

    /// Sequencer-specific sequential height. Zero-indexed.
    pub height: u64,

    /// Digest of the payload.
    pub payload: D,
}

impl<P: Array, D: Digest> Chunk<P, D> {
    /// Create a new chunk with the given sequencer, height, and payload.
    pub fn new(sequencer: P, height: u64, payload: D) -> Self {
        Self {
            sequencer,
            height,
            payload,
        }
    }
}

impl<P: Array, D: Digest> Write for Chunk<P, D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.sequencer.write(writer);
        self.height.write(writer);
        self.payload.write(writer);
    }
}

impl<P: Array, D: Digest> Read for Chunk<P, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        let sequencer = P::read(reader)?;
        let height = u64::read(reader)?;
        let payload = D::read(reader)?;
        Ok(Self {
            sequencer,
            height,
            payload,
        })
    }
}

impl<P: Array, D: Digest> FixedSize for Chunk<P, D> {
    const SIZE: usize = P::SIZE + u64::SIZE + D::SIZE;
}

/// Parent is a message that contains information about the parent (previous height) of a Chunk.
///
/// The sequencer and height are not provided as they are implied by the sequencer and height of the current chunk.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Parent<D: Digest> {
    /// Digest of the parent chunk.
    pub digest: D,

    /// Epoch of the validator set.
    pub epoch: Epoch,

    /// Signature over the parent.
    pub signature: Signature,
}

impl<D: Digest> Parent<D> {
    /// Create a new parent with the given digest, epoch, and signature.
    pub fn new(digest: D, epoch: Epoch, signature: Signature) -> Self {
        Self {
            digest,
            epoch,
            signature,
        }
    }
}

impl<D: Digest> Write for Parent<D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.digest.write(writer);
        self.epoch.write(writer);
        self.signature.write(writer);
    }
}

impl<D: Digest> Read for Parent<D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        let digest = D::read(reader)?;
        let epoch = Epoch::read(reader)?;
        let signature = Signature::read(reader)?;
        Ok(Self {
            digest,
            epoch,
            signature,
        })
    }
}

impl<D: Digest> FixedSize for Parent<D> {
    const SIZE: usize = D::SIZE + Epoch::SIZE + Signature::SIZE;
}

/// Node is a message from a sequencer that contains a Chunk and a proof that the parent was correctly broadcasted.
///
/// It represents a newly-proposed tip of the chain for the given sequencer.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Node<C: Verifier, D: Digest> {
    /// Chunk of the node.
    pub chunk: Chunk<C::PublicKey, D>,

    /// Signature of the sequencer the chunk.
    pub signature: C::Signature,

    /// Information about the parent chunk
    ///
    /// This part is not signed over, but it is used to verify that the previous chunk in the chain was correctly broadcast.
    pub parent: Option<Parent<D>>,
}

impl<C: Verifier, D: Digest> Node<C, D> {
    /// Create a new node with the given chunk, signature, and parent.
    pub fn new(
        chunk: Chunk<C::PublicKey, D>,
        signature: C::Signature,
        parent: Option<Parent<D>>,
    ) -> Self {
        Self {
            chunk,
            signature,
            parent,
        }
    }
}

impl<C: Verifier, D: Digest> Write for Node<C, D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.chunk.write(writer);
        self.signature.write(writer);
        if let Some(parent) = &self.parent {
            true.write(writer);
            parent.write(writer);
        } else {
            false.write(writer);
        }
    }
}

impl<C: Verifier, D: Digest> Read for Node<C, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        let chunk = Chunk::read(reader)?;
        let signature = D::read(reader)?;
        let parent = if bool::read(reader)? {
            Some(Parent::read(reader)?)
        } else {
            None
        };
        if chunk.height == 0 && parent.is_some() {
            return Err(CodecError::Wrapped(
                "consensus::ordered_broadcast::Node",
                Error::ParentOnGenesis,
            ));
        } else if chunk.height > 0 && parent.is_none() {
            return Err(CodecError::Invalid(
                "consensus::ordered_broadcast::Node",
                Error::ParentMissing,
            ));
        }
        Ok(Self {
            chunk,
            signature,
            parent,
        })
    }
}

impl<C: Verifier, D: Digest> EncodeSize for Node<C, D> {
    fn encode_size(&self) -> usize {
        let parent_size = if self.parent.is_some() {
            Parent::<D>::SIZE
        } else {
            0
        };
        Chunk::<C::PublicKey, D>::SIZE + D::SIZE + bool::SIZE + parent_size
    }
}

/// Ack is a message sent by a validator to acknowledge the receipt of a Chunk.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Ack<P: Array, D: Digest> {
    /// Chunk that is being acknowledged.
    pub chunk: Chunk<P, D>,

    /// Epoch of the validator set.
    pub epoch: Epoch,

    /// Partial signature over the chunk.
    pub signature: PartialSignature,
}

impl<P: Array, D: Digest> Ack<P, D> {
    /// Create a new ack with the given chunk, epoch, and signature.
    pub fn new(chunk: Chunk<P, D>, epoch: Epoch, signature: PartialSignature) -> Self {
        Self {
            chunk,
            epoch,
            signature,
        }
    }
}

impl<P: Array, D: Digest> Write for Ack<P, D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.chunk.write(writer);
        self.epoch.write(writer);
        self.signature.write(writer);
    }
}

impl<P: Array, D: Digest> Read for Ack<P, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        let chunk = Chunk::read(reader)?;
        let epoch = Epoch::read(reader)?;
        let signature = PartialSignature::read(reader)?;
        Ok(Self {
            chunk,
            epoch,
            signature,
        })
    }
}

impl<P: Array, D: Digest> FixedSize for Ack<P, D> {
    const SIZE: usize = Chunk::<P, D>::SIZE + Epoch::SIZE + PartialSignature::SIZE;
}

/// Activity is the type associated with the [`Reporter`](crate::Reporter) trait.
#[derive(Clone, Debug, PartialEq)]
pub enum Activity<C: Verifier, D: Digest> {
    Node(Node<C, D>),
    Lock(Lock<C::PublicKey, D>),
}

impl<C: Verifier, D: Digest> Write for Activity<C, D> {
    fn write(&self, writer: &mut impl BufMut) {
        match self {
            Activity::Chunk(chunk) => {
                0u8.write(writer);
                chunk.write(writer);
            }
            Activity::Lock(lock) => {
                1u8.write(writer);
                lock.write(writer);
            }
        }
    }
}

impl<C: Verifier, D: Digest> Read for Activity<C, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        match u8::read(reader)? {
            0 => Ok(Activity::Node(Node::read(reader)?)),
            1 => Ok(Activity::Lock(Lock::read(reader)?)),
            _ => Err(CodecError::Invalid(
                "consensus::ordered_broadcast::Activity",
                "Invalid type",
            )),
        }
    }
}

impl<C: Verifier, D: Digest> EncodeSize for Activity<C, D> {
    fn encode_size(&self) -> usize {
        1 + match self {
            Activity::Node(node) => node.encode_size(),
            Activity::Lock(lock) => lock.encode_size(),
        }
    }
}

/// Lock is a message that can be generated once `2f + 1` acks are received for a Chunk.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Lock<P: Array, D: Digest> {
    /// Chunk that is being locked.
    pub chunk: Chunk<P, D>,

    /// Epoch of the validator set.
    pub epoch: Epoch,

    /// Threshold signature over the chunk.
    pub signature: Signature,
}

impl<P: Array, D: Digest> Lock<P, D> {
    /// Create a new lock with the given chunk, epoch, and signature.
    pub fn new(chunk: Chunk<P, D>, epoch: Epoch, signature: Signature) -> Self {
        Self {
            chunk,
            epoch,
            signature,
        }
    }

    pub fn verify(&self, public_key: &Public, ack_namespace: &[u8]) -> bool {
        // Construct signing payload
        let mut message = Vec::with_capacity(Chunk::<P, D>::SIZE + Epoch::SIZE);
        self.chunk.write(&mut message);
        self.epoch.write(&mut message);

        // Verify signature
        ops::verify_message(public_key, Some(ack_namespace), &message, &self.signature).is_ok()
    }
}

impl<P: Array, D: Digest> Write for Lock<P, D> {
    fn write(&self, writer: &mut impl BufMut) {
        self.chunk.write(writer);
        self.epoch.write(writer);
        self.signature.write(writer);
    }
}

impl<P: Array, D: Digest> Read for Lock<P, D> {
    fn read_cfg(reader: &mut impl Buf, _: &()) -> Result<Self, CodecError> {
        let chunk = Chunk::read(reader)?;
        let epoch = Epoch::read(reader)?;
        let signature = Signature::read(reader)?;
        Ok(Self {
            chunk,
            epoch,
            signature,
        })
    }
}

impl<P: Array, D: Digest> FixedSize for Lock<P, D> {
    const SIZE: usize = Chunk::<P, D>::SIZE + Epoch::SIZE + Signature::SIZE;
}
